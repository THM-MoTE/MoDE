
= Grundlagen

In diesem Kapitel werden einige wichtige Grundlagen für dieser Arbeit erläutert.

== Design Pattern

=== [[mvc-pattern]] MVC Pattern

Das MVC Pattern ist ein Architekturmuster bei dem eine Anwendung in 3 eigenständige Bereiche gegliedert wird:

* Das **M**odel ist für die Haltung der Daten zuständig und informiert andere Module über Änderungen.
* Die **V**iew dient zur Anzeige des Models.
* Der **C**ontroller nimmt Eingaben entgegen und reicht diese an das entsprechende Model weiter.

<<mvc>>

image::https://glossar.hs-augsburg.de/static/media/f/fa/MVC-Module_01.png[caption="Figure 1: ", title="Model-View-Controller Pattern <<mvc>>"]

=== [[builder-pattern]] Builder Pattern

Das Builder Pattern trennt die Konstruktion und Repräsentation komplexer Objekte. Hierdurch kann ein Objekt in mehreren Teilschritten erzeugt werden. <<dp1>>

=== [[state-pattern]] State Pattern

Mit dem State Pattern kann ein zustandsabhängiges Verhalten eines Objekts modelliert werden.
Hierbei wird eine einheitliche Schnittstelle für den Zustand definiert. Jeder konkrete Zustand muss diese Schnittstelle dann implementieren. <<dp2>>

image::https://www.philipphauer.de/study/se/design-pattern/state/state.svg[caption="Figure 2: ", title="State Pattern <<dp2>>"]

== Modelica

Modelica ist eine objektorientierte Sprache zur Erstellung von physikalischen Modellen. Diese werden in zum Lösen in Mathematische übersetzt. Modelica arbeitet mit Gleichungen anstatt mit Zuweisungen. Dadurch muss nicht händisch auf die gesuchte Variable aufgelöst werden. <<m1>>

== OMC (OpenModelica Compiler)

Der OMC ist ein quelloffener Compiler für Modelica. Er kann als interaktiver Server gestartet und über eine API angesprochen werden. Dadurch ist es möglich Modelle zuladen und Informationen über diese vom OMC zu erfragen.
<<omc>>

== JavaFX

JavaFX ist ein Java Framework für die Entwicklung von grafischen Anwendungen. Durch das Beschreiben der Oberflächen in der XML-Sprache FXML wird eine strikte Trennung nach dem MVC Pattern(siehe <<mvc-pattern, MVC Pattern>>) realisiert.
<<j1>><<j2>>

== ANTLR

ANTLR steht für **AN**other **T**ool for **L**anguage **R**ecognition und ist ein, seit 1989 von Terence Parr, an der Universität von San Francisco, in Java entwickelter, objektorientierter Parsergenerator.
<<a1>>

== Project Lombok

Project Lombok ist eine Java Bibliothek, die sich zum Ziel gesetzt hat Quellcode, der sich in ähnlicher Weise in jedem Java Projekt wiederholt, zu beseitigen. Um dies zu erreichen werden Annotationen genutzt, die vor dem Kompilieren des Programms Quellcode hinzufügen. <<l1>>

In meiner Projektphase habe ich hauptsächlich folgende Funktionen aus Project Lombok benutzt:

=== @Setter/@Getter
Durch das Angeben dieser Annotationen an bestimmten Feldern, werden für diese _get_ und _set_ Funktionen generiert. Wenn sie direkt an die Klasse geschrieben werden, werden für alle Felder die Funktionen generiert. <<l2>>

[source,java]
----
include::../source/GetterSetter.java[tags=withLombok]
----

=== @Builder

Mit der @Builder Annotation wird das Erbauer Pattern(siehe <<builder-pattern,Builder Pattern>>) als innere Klasse umgesetzt. <<l3>>

[source,java]
----
include::../source/Builder.java[tags=withLombok]
----

=== @EqualsAndHashCode

Diese Annotation erzeugt für die annotierte Klasse die _equals_ und _hashcode_ Funktionen. Ohne weitere Angaben werden alle Felder der Klasse benutzt, es kann aber auch Festgelegt werden, dass bestimmte Felder für _equals_ und _hashcode_ nicht beachtet werden sollen. <<l4>>

=== @NonNull

Ein @NonNull an einem Methodenparameter fügt direkt zum Beginn der Methode eine Überprüfung auf Null hinzu und würft eine NullPointerException, wenn der Parameter Null ist. <<l5>>

=== @UtilityClass

Die Annotation @UtilityClass sorgt dafür, dass die Klasse selbst *final* wird, alle Felder und Methoden der annotierten Klasse *static* werden und ein privater Kontruktor erzeugt wird, sodass kein Objekt dieser Klasse erzeugt werden kann. <<l6>>
