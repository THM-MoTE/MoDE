// Generated from /home/hobbypunk/Dokumente/Entwicklung/THM_Projekte/Projektphase/jModelica/build/java/src/java-generated/org/jmodelica/modelica/parser/ModelicaParser.parser
package org.jmodelica.modelica.parser;
 import org.jmodelica.modelica.compiler.*;
 import org.jmodelica.util.formattedPrint.FormattingInfo;
 import org.jmodelica.api.problemHandling.Problem;
 import org.jmodelica.api.problemHandling.ProblemSeverity;
 import org.jmodelica.api.problemHandling.ProblemKind;
 import beaver.Parser.Events;
 import java.io.*;
 import java.util.Collection;
 import java.util.Map;
import java.util.ArrayList;
import beaver.*;

/**
 * This class is a LALR parser generated by
 * <a href="http://beaver.sourceforge.net">Beaver</a> v0.9.6.1
 * from the grammar specification "ModelicaParser.beaver".
 */
public class ModelicaParser extends Parser {
	static public class Terminals {
		static public final short EOF = 0;
		static public final short ID = 1;
		static public final short STRING = 2;
		static public final short ANNOTATION = 3;
		static public final short DOT = 4;
		static public final short SEMICOLON = 5;
		static public final short COMMA = 6;
		static public final short RPAREN = 7;
		static public final short IF = 8;
		static public final short LPAREN = 9;
		static public final short PLUS = 10;
		static public final short MINUS = 11;
		static public final short CONSTRAINEDBY = 12;
		static public final short FOR = 13;
		static public final short ELSEIF = 14;
		static public final short ELSE = 15;
		static public final short LBRACK = 16;
		static public final short EQUALS = 17;
		static public final short RBRACE = 18;
		static public final short DER = 19;
		static public final short LBRACE = 20;
		static public final short UNSIGNED_NUMBER = 21;
		static public final short UNSIGNED_INTEGER = 22;
		static public final short TRUE = 23;
		static public final short FALSE = 24;
		static public final short TIME = 25;
		static public final short END = 26;
		static public final short COLON = 27;
		static public final short LOOP = 28;
		static public final short RBRACK = 29;
		static public final short THEN = 30;
		static public final short END_ID = 31;
		static public final short INPUT = 32;
		static public final short OUTPUT = 33;
		static public final short FUNCTION = 34;
		static public final short CONNECTOR = 35;
		static public final short RECORD = 36;
		static public final short EXTERNAL = 37;
		static public final short PUBLIC = 38;
		static public final short PROTECTED = 39;
		static public final short EQUATION = 40;
		static public final short INITIAL_EQUATION = 41;
		static public final short ALGORITHM = 42;
		static public final short INITIAL_ALGORITHM = 43;
		static public final short OR = 44;
		static public final short AND = 45;
		static public final short EXPANDABLE = 46;
		static public final short OPERATOR = 47;
		static public final short CLASS = 48;
		static public final short MODEL = 49;
		static public final short BLOCK = 50;
		static public final short TYPE = 51;
		static public final short PACKAGE = 52;
		static public final short NOT = 53;
		static public final short PARTIAL = 54;
		static public final short DISCRETE = 55;
		static public final short PARAMETER = 56;
		static public final short CONSTANT = 57;
		static public final short ENCAPSULATED = 58;
		static public final short DOTMULT = 59;
		static public final short FLOW = 60;
		static public final short STREAM = 61;
		static public final short LT = 62;
		static public final short LEQ = 63;
		static public final short GT = 64;
		static public final short GEQ = 65;
		static public final short EQ = 66;
		static public final short NEQ = 67;
		static public final short REPLACEABLE = 68;
		static public final short DOTPLUS = 69;
		static public final short DOTMINUS = 70;
		static public final short MULT = 71;
		static public final short DIV = 72;
		static public final short DOTDIV = 73;
		static public final short WHEN = 74;
		static public final short EXTENDS = 75;
		static public final short END_IF = 76;
		static public final short FINAL = 77;
		static public final short OUTER = 78;
		static public final short END_WHEN = 79;
		static public final short INNER = 80;
		static public final short POW = 81;
		static public final short DOTPOW = 82;
		static public final short ELSEWHEN = 83;
		static public final short REDECLARE = 84;
		static public final short END_FOR = 85;
		static public final short IMPORT = 86;
		static public final short WHILE = 87;
		static public final short BREAK = 88;
		static public final short RETURN = 89;
		static public final short CONNECT = 90;
		static public final short ASSIGN = 91;
		static public final short END_WHILE = 92;
		static public final short EACH = 93;
		static public final short IN = 94;
		static public final short ENUMERATION = 95;
		static public final short WITHIN = 96;

		static public final String[] NAMES = {
			"EOF",
			"ID",
			"STRING",
			"ANNOTATION",
			"DOT",
			"SEMICOLON",
			"COMMA",
			"RPAREN",
			"IF",
			"LPAREN",
			"PLUS",
			"MINUS",
			"CONSTRAINEDBY",
			"FOR",
			"ELSEIF",
			"ELSE",
			"LBRACK",
			"EQUALS",
			"RBRACE",
			"DER",
			"LBRACE",
			"UNSIGNED_NUMBER",
			"UNSIGNED_INTEGER",
			"TRUE",
			"FALSE",
			"TIME",
			"END",
			"COLON",
			"LOOP",
			"RBRACK",
			"THEN",
			"END_ID",
			"INPUT",
			"OUTPUT",
			"FUNCTION",
			"CONNECTOR",
			"RECORD",
			"EXTERNAL",
			"PUBLIC",
			"PROTECTED",
			"EQUATION",
			"INITIAL_EQUATION",
			"ALGORITHM",
			"INITIAL_ALGORITHM",
			"OR",
			"AND",
			"EXPANDABLE",
			"OPERATOR",
			"CLASS",
			"MODEL",
			"BLOCK",
			"TYPE",
			"PACKAGE",
			"NOT",
			"PARTIAL",
			"DISCRETE",
			"PARAMETER",
			"CONSTANT",
			"ENCAPSULATED",
			"DOTMULT",
			"FLOW",
			"STREAM",
			"LT",
			"LEQ",
			"GT",
			"GEQ",
			"EQ",
			"NEQ",
			"REPLACEABLE",
			"DOTPLUS",
			"DOTMINUS",
			"MULT",
			"DIV",
			"DOTDIV",
			"WHEN",
			"EXTENDS",
			"END_IF",
			"FINAL",
			"OUTER",
			"END_WHEN",
			"INNER",
			"POW",
			"DOTPOW",
			"ELSEWHEN",
			"REDECLARE",
			"END_FOR",
			"IMPORT",
			"WHILE",
			"BREAK",
			"RETURN",
			"CONNECT",
			"ASSIGN",
			"END_WHILE",
			"EACH",
			"IN",
			"ENUMERATION",
			"WITHIN",
		};
	}
	static public class AltGoals {
		static public final short anonymous_short_class = 97;
		static public final short exp = 98;
	}

	static final ParsingTables PARSING_TABLES = new ParsingTables(
		"U9pjVGUS5KNoV$LitdqBx9BZ8YZWcTQ0Uc8M4uXuPmvumNY6CoEeTuev77e6157FX07CfwS" +
		"YmO2182Zc0A8YvW2YgAU#$d#hkdkcPzxCUulXv$q$7xO#tLrTtLtrxUeuytRV4gqvJ3SaAV" +
		"z5$WiJSogIfq2B90PfRMHKNTZMaRfQNH#Nq4MUXTT4SXdzGqrL2oX7TP1Doq#ZrXpdft5Ew" +
		"Y5MyrLV6gSR0WB$c9gbvgYvwbdTZVwC6bSNK5uzd5#ihyvhGuxJtVAQsb9dn8twQdKdqiAs" +
		"8L6LkYSX6U$n4oIU9$XVXryMmSeY8KtLLCavhf5VWlZB$18wcZM27vyaEbBteubwVDx#E4x" +
		"to#Tf8Rs9#1BKUWQIUmfRErBhq549cLSReyJnARfl$bbQGHtppwB5KBMcMYkVL#lfliYz8L" +
		"eEW$KNQ7J#1Jq#Q0B$PfpeI$M27gV7WKE$wKGwWBQY7MadEfWsetrf0#fF#r1VjPJMe3uOm" +
		"pSpwLaQ5vUeVfwLYoLc2stqnVfwVNt#JOw5pj1dS4vgFYU1wKsMvh$nYSReCwWB#l9D4Qnh" +
		"qXWQ72YkbKLwh1wRqFnKnAkFfKwPBbFR8hvENuVSTPPErwTpJceype49AKiRVLAzKBTHjKR" +
		"OeRHdusrZUXhKmBY4NlJuHHBpZ3rVdQF$1MgK69J$8F#1v503AyxKkWWyIzlwX97xGBTLsu" +
		"4hWfJ#nKZLv$6sCJs$exqIiZMyqgwIhWbQWyx9Vvd$KhVbc8bwGTgM9S1neS41h6tfZv1#r" +
		"o9Qb9#HNqH$oC#Wcx1QTtNop1wj7vQUdPz3pw7r39fBL#agNPN$ZWDLq6g#1ThDoyqGcgCk" +
		"LfrKPvQeFMYvsaqTeHvKauCAh9Jlp9wNJl0unpqnL$yApQE3jlfiVNPOEePse6DeDFQGphe" +
		"pxK8xqnOqW3fGavGEe$RKGDVH8RGjRKS3QNiwdawW7jGTPUs2JZ4xkqUylbPVI#KSCqbfCx" +
		"W7zOFqBiVwGSYc5YVr7uv3dsx3FWqsTAMCMzr3ezNEFkxySX2N3bCvcft4dVyOlf#AUAvlX" +
		"#PulBFsRxOcacOxur$EVmpw8JzL$xiugJgEwIrwczvnOwYsSQNYxprfj5uDr13w#ozqc9GE" +
		"qwlHn09$NwksHcaNa6S78nRo#M#fM$vRn5$3rbPIsepQlA$iZD0t0ARKsRaHzUTswQJQKwU" +
		"uX5xo#0MIcbDh4Iscfv7x0UlXPDKn$pQzW1fZfDxe$BSyurG7y4T3Cb$z9JzVQ54MyTcVaA" +
		"s8UEZbU7ImYJuIT8s#1gVbDOPeakhBEQbn90Bs2Je2abeEkfR#oN4XgPiv5lsBhPMBSExPK" +
		"fbjOx5AuCFWZ$viaz9XQdpXRADhwJcKFaTpVJlqSiJd5r8d#YQ$a8bEbzBc$4ASnRXbeDth" +
		"EWTPJkVeSeuBYLPmhAwZh$WiLckezUWqtISiPSpZWVayUBzF33EN3Wk6fgyGdUCLujjHvLw" +
		"kdMuNTEDOjyk$AfgQ8JbGTzLTUONeQiYgiubQITnJTpKh91YYbWH1M0hCGGwhevVk5UpcC2" +
		"liHb8wJFUYrz9s8vJs27h4xDH6VBWw9WJjbTZ2geQ45gd5B0ywGvAsEXukjZheR$JtX6osL" +
		"ofpFxyWlm3S0Y51GHto2soDzb4xhBJhiKfQST2jr8OS5nBTAF7YOD$yX$aFMHjMshTXANm7" +
		"wMZzTz3TeU$AyXzAwJ3zTrgGz1rapw7qReotPqVry7ANw4loSpdMbwXxHLEplaHcQ3rfNGz" +
		"g9N411NjnZ7FdChgKZjLDe54WMohxu4oWRQ9PUbIu3pw1aURIONgKQfKwqlNwK91lPsCljr" +
		"ml3uPmh9TZpsLDpNevUqhNS03LIrn0k95ptDFUoB5ArDPOAQwKqSu6saDrT$fpwDiSq7BfC" +
		"BL5i5KgsXhKd#3RKGCYFlzVq5o9$mlVigRc$7$5jtMgMjU1QYGk8DMEOpxJLINEYz7qYko4" +
		"jbHM$clcZA4beM$V0reknHaJ34f5MuVUN#7ReOyZFly8plLv#KTqJr23b3Rhm$HX#O$aXl4" +
		"Hf7MfgsWgzUTsZlIysEtb8z0ZFj6t7bzbqu$qBAHVWKmCqeUfd6eMoIFvjr2djngaUgjTwN" +
		"cr4VjGRQ3Qq0nfvopFyeckfB5nosgWn#zfBN#cdqRwTDx6#h7yqrIjsi7oqrAl9rkMjRWhW" +
		"h5ykDeObf$sB3$jazgElajOxkRrUP6qcAr8pzQpZMNSMv3YpbXD4qFBwwTOhb6RmlBiBE8#" +
		"noMgkrUwGDBfk5bCrzEbjxDzouo6QmIj8HVBa228vT#epM5vUYPT2OfBxefuzOcaqzHdUfg" +
		"U9fQdHvRLsgvsi3dalNKbQBg42bsXrjKLi3mjY#XLz3akkzVZ$oJnPAIJzMInF2soh1zmjO" +
		"CT8U#joq7J90IW$#W0bYTdaMglxqz8DekLSlemdk0VHhoOVa3kFgsqKXqHb9wCdGCrQ1x2u" +
		"c1lrG5jlaBeg7RIO$GOUfRRfHEzZpqaBfaGyRXDSZfLRQ#dwgdv9$DFweSvfWcgKVy6z31B" +
		"q6OCwcw5#zkdo46gIHFQ41tDxT99LS3RCKbG7$5uXkHqYfw1C4L$3fegyUTgMznTLfSSrvk" +
		"avIwkJaKEKfdb4p3NJBjKKhkeTHAIVRpSdoL#2Eb3#Y5QGPtq5DowvEP4pwdrz1Ju4pMidF" +
		"VWAUeuv1d5tzJ#wFD3MQJgqUUO96WLyLXLdCxHpoBCaLNpaBq1JDIzGG#n1FKcGLCJZLK78" +
		"0UfzFbBb4cxT5AhgTg4P9YNUuTZx1G7wvdOKRu0pP7u2tMCRW#Q8n8yaQBMy$Hy$dda89NU" +
		"FwfEruzokt0Fc#cJ#gFwGsBVhlBglcttjLFqKoZXszSZfi$0r45tm1uckpnDG9tZQLxGe7Q" +
		"5T2FnpYCSk5sexQaOTTGT4vPFIZanEibPjLGlDJ7eRJdLcrc2yjcmVABiNBkgSytk6QocBi" +
		"s$dNrMwKwwKznoi5botuPiVx6yJ2ypiLu6Nnsgfi7oCl79S8GHYNtxD7ML#dksPTLUdP6mF" +
		"C2pl41YrdWsPjNYO5laUAT$2pl9#y50M7vVTBu7o#VfzrG7UBkDsaYtqMte98xZ79CQBUdx" +
		"#drw8zXJNOPRsdiWMnfqanjHW6UmtOCzr1XtnmWEuDBykpGiFmLnyhRvBahVaZYoCoxYgOE" +
		"wG9sbb#09w5EzH6G3SCSO03fLOb3#7SSnuGc8um$DsyYWAzRn4f0hxI0teMjnFsfFd#2UP5" +
		"7gKxXK$GuteP5gxmAKYr5sAySUdUdPP3$VJdbPmRDeQxfNRmgKcu8MIGnITpcE2Niln$DK5" +
		"Sz0ceLPMAl$5fRE5bzEm3xx3EhS5pwfBU7I$18ygRMXiGNtDTPv6iu6tyvk7h#GtfHrl4ZT" +
		"fXuLsIP0kGdeJOb1wd77IMw8n3kgb$GT#WxeHwos3Cll49HZQBHw2#5j3oLA1MKlwbo0SWm" +
		"qFecRg6zdPiGBIbxpRyAdiqMsCL1k35eeCKWzupWcQEHujFf0dgRi6mPNoXAC#3n8pj7dgE" +
		"Syb5pAABSizALUWDApG9uTVOndq$boeRfR$rLa$O6oF#Wl4ZCT7d9C1qbyBkXsVJjyoV6yi" +
		"FHsyINkxUfLzQ9Q5ixBLxXKVOrv#GTT#Aps1agF0dbsrFSHJntqi603$NgmFdqQj1FPHa2v" +
		"4UWrYK511yS9VIQorOEU#IVoJs0lvdYUAmKFbFeLVZVehnxuaalXIpmTl9546Qo1qYD0lft" +
		"N8rvyoUzkNrF716k9R4EWt13nH8wPWYqSvycF1atIauBjECPkvCedoJk3dR0JTT6VwXz2Nt" +
		"udfQ$2bn$hZmjy#L#KVGJox0JxU3PvJdwYFv6t0$k9R0EWt03qZSGW8iSn1N#Gz0hGdVfEZ" +
		"3Z7yyBoE#Nf$1Fuae29F5#YLERbpYbhd2rS3lBi#5RTwY7Y8BBrWN9znCHndFDob#dBf8UN" +
		"walbJBQbPlK07L06sqSeSMj3QR0BHfomunMYN5$$4rHen$1OEKJg4NsLlihAcu4IX5opJd1" +
		"HBkmPdymxg2V2qWKHIlbnA4qh4fIKWfBBKknOFlHZM6ize5mFCN4SvwASxTtJhdrKcedIb6" +
		"QXN4$i5zYnlB7sYaN9idM1Sbt4n76SYtA#Bz5#OLIQYTAKPg5SL#mNsB5yt9SiMmSerq5C7" +
		"CUvA6VHlHFwCYpDH6bAir2k8$OBx5ZUM7lNecJPsa2vDcBYECv5kOGlFurACr6QqYoKQulz" +
		"0ZkMZ$kIPMi1vLg8YUCu5#Kikcz2NuQbcIXDQHRAjSH#WHtB6slQecHPQw1iZPWuZdDHphG" +
		"B6ctQCInr68sykyDeMwLZv1EwTR1rcXt7czxdNvPz619rkHfbDAkRyYz3dgaPA0QZncDCN8" +
		"LhU$IOJoXzZ6ItKLsAVifvk7pAEL6qyUTcBuEJLCABXjH8URzcSwXXkVmqZmzBpK$8NKX$J" +
		"zIuW6wZCydx2UlUMWJhMhRcIAbzg6jZyEZHXepKvNmkudsPaUTVPogiO#IEOETrqmfyCP#E" +
		"ai#unRhHYHQFYvt7eVKVbaoPpVbSn3lAFyxjMHxvD5w3JgMRdK#vDYoPkYLn6gtEBi94iJy" +
		"HuI9BfipcV2xYGvh8xLaUZMwy1fqHZJtN1hcw$9xZaWoiWyId5pdDhet5Sw4bKsPpFXVnli" +
		"p8y#yp5TOnSaTOVHkPLkeVHN$3uNr1AjQDJcT7z5zWwK85BxYSpqMyBpFo$ADCXNMCt15cm" +
		"AFIgYHAzEKzOzteT7P4$$cMJ9dD#Lp4#p8h$u0ffSu7Fg7q0xGgDaTNPvn1kT5aWekTH9zd" +
		"wNor27cRyxc8zsLM$ZLJIfslVKBfrrRJrwNtKsFTw4IuJNJVfi$BlsJ8bBcSpqLyMFSsRi$" +
		"oQEt7Q$ZxATVMjuLrY#sdwrYj8wNs2DV6uD4xGjUEUaVc39byF4V3AVOJbcQSxxPLnlcEdp" +
		"jzBPwTJMa$kbjlYzosBXQksN6Hd18$OMas9YxDn6Gq5jgnj2LoMxfOk6R7HV82JAuq6nENP" +
		"cFQqjSIjm$Q0hajN2nSi#CYUG4cLvgDYKkpCMtXQudR1ssEtEOk5gxPSP6y09ChpSR4fTcO" +
		"DlUrnEs3DaDkCnSBr#ouI5w0oPLcO#BIR4oR#LhYza4x8RUJYuLhTbmaBy3aIkEOoCF4fQN" +
		"MNQ4Ti#wsGMuR5mlNxBX8Ne39bMPZuj9iFstZQudR1ss7t7Ok5gxPSP6y09ChpSR4fTcOjl" +
		"ErnEs3jaPkQnSBr#ouI5w0oPLcO#BIR4nR#rhYza5R8RULYuLhTXnJCDIK9Z2vkjcOk3GRq" +
		"rQ#bhXzq6#fbVujOkAOAHZYk4XkBTQ7c5nfDYOkpSRqMrzBt3u8ElKEBevpKQx0Jwuq6nEN" +
		"bbftXNRCkjiUkUrT7EUYN04cLvgDYKjBOIgqOp0DH6wWY#DSb7Ccyv#RE2pDniIbfJ0LsZ6" +
		"OTjRV8#mCsSw6K7bZki$bOD$8oCSLrGtwY#mD9bCUx2hsfDJ87N7UwdZ3rV6i$eSUbAVxLr" +
		"mV$QTx4QJsCHX6PS7lQ5bUtggftwlTeVyLdonmNtTpYkwbQVvJyaGcEhwms6EwrKXvZf$cO" +
		"lvDMURnCqxti1ptzG0E#e3yD8wPZEuePsAdI$eoqfLxtf$cweI$g$kjzpkyNFQnYwLq47GC" +
		"Sh7X14#OupXyx$6i$9RiiwuqvRs8GTR5QfBV0GonFUl82ZQaoJI5fj4Zz5XKPigzt7GJsn7" +
		"wc4OpYlWCL$tGPfZeJVx6utH7wCdpyXkCpuTufllavmtleyzFryyxYbfpBDvwtYS$JsCaTZ" +
		"FsJMNRg#M8tBixrwRPUuTzWuGRx6XOpiZ0fprvJCUJXsqRpGTJFoJeLnzblIDN$rKpr5FIw" +
		"YOZv#UXI9E42mmNILHxY#byFGBf23t2biOuvlLNj9Z#gqy6Tx8#MNK4bgxCsJedYxI3g#ye" +
		"wWkTYnfVCT7tHeT7N$aajepMhuo628iBJZTRPct2dsnhYGGzEzdWqyEH3jVsYIpECQzNqE9" +
		"WKtqIk9FqITopuBVCsJedYRI3g#$8wnctMy4KR6DqUBJ29x5bjAum6Y8iBZZTR9cr6VtEZW" +
		"i6dpuHwOdwH5iQunoF7ByXFa7BUQ7MSHngdE3n7jbc1ka9vjDxj5pFr7TaQos3jshDpio1M" +
		"#iJWogE7HO9dqUwsRAWuhSS9mGr4KQ3KzBZaHwlZoVPcIr7XdCySiTnu5XwPZdKECxZFOhr" +
		"x3YlPyVv58qhzqnqSy#EPstIin2BXCyZtMoPDGUz3RO8ey4fwR58ZzN7sj8OvtZaRkI0cD$" +
		"yxIUSgNEZntiaA0#AsaPwV3Ao$0#6QBv9zR4SM2xnB97COjxfnhuBouXlzFKRZCw6aQ2r9R" +
		"IQ9zRcyRujt2oV$BpXrLwYrlnjnYoqioIQ#UtxBFsowcDrUgJszUkw5kw7S$fbH#Q6WpgVk" +
		"rfHcIbFyhuk$JBQMOfa9h1cd$oyuH4larDm6Kv1rpuy1KMIVS$3pIk$p15gpvGsCyDUBlF9" +
		"pni#vf5b#PcEf0SlOUwihjrRhfa##Nd3npJDvDQE8bdecvTyYjUDMhYwYNFnjxIPawb$fhw" +
		"f$QkygItsBlVFyXdEZUe4TP8wMHsfZehVisEVCF5TCjt$nJ0yOFyUCdPFX8xcy7OuZhaGmv" +
		"N0GEwc1$c1yWcJkSMcObCZVpIsDFziZXguDmJh1ci6wrbB3jk$r571RuBce4$GD#WNh1siO" +
		"x6bUVXHlg$W3jj2#yLgXFPlW6yARMtY8Rp5rVYPBDwHQl5#p#BzBR5exiI8qpprk7ZAwNl8" +
		"Z3yaEob#xfxhtvRLuFndekcpS8LbtgpLrjvTtDNzp17Mqto#MNECT0lMwPEVDxn5PPxuFjF" +
		"p7I4tGshC25VgV9$ylDh4IBnLFL$#Fj8zOImLoT8GSS4JYFbxIjK5I3gfphucrIk$r16qc4" +
		"ypeyzKb$havmqVyzDI$Q8Zw3XBju5GVh$IwFGfbczZ9D4wvPo$XuYExFSiHh$t#vL#peApk" +
		"aMIzXoRgjiynqhVNecbjnXj$AoP$zf$4ulzQGPhGvnwseG$PwNhZaOLpyWpU4U9viTAZcge" +
		"oMY8zAoSfaYFVa7y$4BBzUJVOp9rzGkEKEyzd$moKvxaVzffPV#k#cYpKsIVL4LcGceRzFC" +
		"cyMjwc#OYcDQBZRGxgQunlp#Hz2jcGi7uHBD7VBit1xrt$XMEcNXc6XcJuIZvqy#LIjszEB" +
		"ZOSBGshHlbh2p#yvkmBklOWuEB3ISwmfoLnNwykfpRdOEBBRS7T4GvYHCwmbB9$Pw3Yot7v" +
		"L5EueIEi5Hokt5miUMuFCf9dD0HbahkTnnSR3akZt8I9tIuqiBvyq1Ke#YClrq#4nwAcaDT" +
		"R3Xf7UOYcMSzNdTN3Yws79T7EOaJEi9IoGtXu6BBSNcKu$YEX8wmL7AxS72nvRZSvGuqieI" +
		"EiAxa1dDmiUMuFCf9dD0HbafkJmukjXoNHpcEusEp9MxSUwR8USmUicQmIagFg3jtR1l$tE" +
		"6V8ayvuSzP4fVIqzmYFPcVHrejVuAUL2tXszQpIZzbm4gplib$LsYUU#LT8GaAqZVxvPP3E" +
		"R#nS#yhzKq#sT6yMN$8P7cVFlJ9imGawYDdIHtYB5cRyguGvV5UxO$nloagJo1nt#RZ$x2b" +
		"2NwVbBblBbTJ48VVvbDWwIvOck1Pck1JqVaroFewuzCIwNFg$BBlHulf7bBoX1vQiiRlIzR" +
		"OesIDlKlMEAXaZUDArhYXP8qdIpvVjorPuqybQnnRiiOL9MjSKxB6f98r$bsonlIIDRuhLI" +
		"EG#Q7tnxhPtyM6axKTvYJT3#b#BXOovJPdvViYtTV5GgRSvgny7wJxk5Z8bDkSAmtNjNl2C" +
		"QKjsRypr#IgDhzOcp5IEfhaCzpmJ1acEtrfE$wEddacA$iy7v2$eul8MQV8klf8VQkMnyuB" +
		"TngPCySxz$GX#f0YslsV4AdwCB6wxg7mzv3KVDxzzKrfkg9FnzGAgOKJKNsHFDEYCo8cJSM" +
		"OZLpzu6l8VsyeABFSv$dlvNtmzz1Gm#K93PxVujuDAetVV4pnSpPgmpPYTuo4LlF#sQ$1aa" +
		"Xhq3$fmM1NSv$Wd$1USbFIk$vOIKdKvez#Yh4oys4APanXtqaVw6dD68$47IFT8sdU72Fz7" +
		"gtMaPjAvgt5QxF2#ifybyzojLxuURnzvsju#udHkFmqyviA$e#fevz1dUguPmoFDVDaqfig" +
		"R#z7Jt0xM#zW$KoCRkLsher#CaPFw5j2$p$X4$AtvkU4PRVwXFpSg1roj$Y4dio9okBVTgR" +
		"dUgtc#fJbB$aP5$qcHSnV2ekhZCgfWYgfYggnMZYVi$asr42D8g6m1b5NweOQDTH4FMarwa" +
		"MzpUz9upRJZzQatz1Qr8fQunbcFTpvryUfl25j13iRqoQqAN$Y02sRO$yz2AVs8NIeQ1qeD" +
		"kwsDWP3zn3Q5JPse#7qC53iGQVGNdGQV#CGdKvdIBq3sJK9z4GNuzaZ5vOqs9Bkq7WYdOII" +
		"au7#4MYiB89#53sNGD$TGwy4VRd5prO6MYi3OEKweCy9UaNyv5zE8u5#5EsLWfPZbOAsaMe" +
		"4Muv60Err9T0Efqb5qDO8McFf8k0e1zfBw9zqAT1U3ak3wUaGhS6s1sI5Q2VI6vBcmd4xZ0" +
		"wdlz0HT2GTHKVJN#aOEXOtOZxHL16q0z6REDeX7jgbtioeYVcssiwCN07QHg2DOrMOdxN85" +
		"SUgK7CMQcLZPLrnhFTuMDyNhCxkZyKwKB2#8cDTshFPMB#XSGciOpoiLyTMN76ifbOQrZQ2" +
		"zPaMpO5PAxKxL7bOWt36DXRCWQjanXgi3tfOArBNLmtGrg5slLWqUraPQbLWXPJZoQk6UiX" +
		"UrXrfTe$MfdLiQHd6YFjqAYqEBGsWC#bTsX8tfQrf6xdN$GVtkXtathIpxLCJi7AVVcUVN2" +
		"DF4EtV0ioZWFazM2gdFqWjXvdx#mMaAjRs1dY9CRUXM#XVr9RQKNlgG1sf4tMcBdGhtGPDz" +
		"q67Zxc7XvdnV1BYOSpzWOUbBrhf$YLz$OZWZljqUGptSsXR7clBlC4z4dgIk1LypnuuDORx" +
		"J0ztt9h1xMGyQWDQWFi1mMr6pTKR4SFz7ukw8MnRZnO6ToDg975tnReS8DPytCh3xH3TZNf" +
		"tMTpTG#iFmzB#cREpsAbGbbXZLtfhx1gPZyxoFt3$6YYdLnNkSarq1TQOaZLMZZN6lRqMQs" +
		"naR3$uiQlRdPvtYzxuwfw4thhLNGdBhEb#uiy2zYewQjt2MyekuGbG4nkrHyFpkd2spKkPR" +
		"LrbjfKLcMrixNbhhI5S9SFbbj549vTSsHS9vaVjMVmrpkBaofw7jbMGDgPW7lwZLWZZ6Mdn" +
		"L8MOFnS9ZsOfpFVQtQYx7St98lKnNs5NnrDXssl3tQWnSpTge2TYc9Uah0v5B#D4CvXPSZN" +
		"6cYsz$QDMnurqKsAEbXNCqS2U5T7zz0PumfoMjuJtqoQCHOqtH#$By5sL#8vNcfltbw6cxx" +
		"j6wxlAiEsLA7M#kwR0TzralBkN6E#X5i$kuNZp32NCK2xTFmFjMtQasRC7MbJnsJaMQ1jfl" +
		"3Sx6yAHxfOvqgpRHtjl0kraYsT4xDmXUx$AGgiyjEP6FYxXsnpGcht1jHqPehqh4srtjFNH" +
		"plXPVFj0UAPFGU3dWwHldxOpuQKKjDchY7llessAhQ9oMKMijSQYDPxZ6mQFv8zPHIoFhw8" +
		"Nl5KqofunqyLoVAVV1JroEtqJLb43HdmPLj6fM4Nim#laEItRybbqTiBoEC$ogzPoHS9oa$" +
		"ZpWT3o5B7CvUO6oPPNbB3y36gMkcV7BO#GFfyAoogqV6QAvOgLxdFQYQv#0Sk5pq6LdkMXr" +
		"lBkgPOhOBbxgcNcAcIThaoV$wyi3oyOvmRFyd1hkTAxFrM4kthy$iIbV7$g1ikNXVYoBVE8" +
		"PByx6PSopZotLSgJt5tUKwSxpKQkbBVJvdPPmNekZrcUb7Y6v9htouqns$80U3HkkI9pd2#" +
		"obitDQGHkJeFXJxPS1iiLuhyzCAFtiYWQLhBFQQkgiC#geC#iQUHAz9drn2tN5Dn1#1wRjD" +
		"mGipn2tYwS6eupzxuClIzsGozSpwDQP7bmmGohG8thl3wRTRKobcjIJen2RySjvnBZx4wCO" +
		"jukj9msjuSNM3RFkyvoXLYExvwLi5orKZj9uGnpR$$CJi8pIM6lKBAJbCUyVQrtrwp9k65K" +
		"oWs3yOobHQWpNdXtmnWfTuoFeUjJ#Wnvr$fBkM7mZU1Rb1K#NGmGBFuDOnVlXd63NHN3SJS" +
		"kbni6sPjwXNVg5pu1JRFh#0ciOn$b3OAo1tJTGi$AxcPGxY8e9mBbBhXhfw7SCu6o8d5hwm" +
		"6lC9xnCPGgH3aqvMvPZZPSQxpKYkwMEK79jwkX294lbQ0i1qeUopIKGnCe$RT6x0UUMODb7" +
		"QUZh4X5kRzNgpm5vKAv1nUYP6jfA2kA#99HihN1Ci8hWx974PGLzZIfM0bVSlrYADDzMP61" +
		"ia9GkgUqR5zoZUI8xmcKVEze2SfkiTLJWRr3OU#unTxF2trPbV8yEGshEHlbO7bkzbTFvCk" +
		"c59JJKr0EJlYIRG#6xTuPA4UcZBZpvLYfDJw1SgJr9OKeATo9M9v4IIL6d2svdJi#uk5dM5" +
		"glz8XZNgBLOArRDYzHhm0bP0Mh1x8A10ybIz9G8kUZJ3wJ2qhKOPHZF9HN2ygnr0QoyIkD4" +
		"Yi7#PEvpagXT3LuvLqfJnS6vJKHIlvnAC419U8s8ar1AV8ibA4VfLRBKRhUkPeM9VXV0gMr" +
		"jj8eFLyAsbyMvIfVhlBbog5C#D9X3EKMeq6PZb7sYG6C8GkbjBBlWYtAgFVsix8ipOAYoTp" +
		"DfKxyVXwxcwDqO#eljJPhmQUSWr1l5$Ck49nv5rY3Mu1xQxsVl5yhG4fTqyR9Za2JJVaTTH" +
		"pfxNG7tQcz7uCKwKF5i4gDGJIRTa4wbv6AP7S43sbYHXNnQOJqb$Efr6QVAaOAV3yAAP#oB" +
		"VUfVIOpI4lYP9$#SaXJVEgDlO#q9LZZI7#rqN$mvq1Ah$$II5iqzZD$VP#sm9ippTelwTC5" +
		"gzP#R4Nz#FsK43FM$OgUdH$es4$oxBJIwfQSdI8hVi9RJ3eypp5t2Z1flGhJAaohC8by5QP" +
		"Lc8fYek6$1YQwDu5fSfQVwAbVoqywvRpxjSVk$pTCVFDX3B$uVA9Yc6XWqayq9F8Jk3r45j" +
		"u3mGzpc10Nt0DjdSqoC8LFzrBktV4adtx7#oFzYVvCrvix7asWctNYDkhy6Ud6EYxGJO#b#" +
		"OzlerhkZpJVwedV7$UJTn7ctQXvsze$rEYFfhiJTlNyp3VTWh4tdXCEDrtdvr1FmMXY$19l" +
		"ICoyqVOzJk6Sa$BuNTIE7tp4xwIZEPSvVdPyvSOSOWi$$RHv7sNX4q7Yjq7j22dvwuJon0p" +
		"dJp$Rq6ufe#$PTEX3F9asmRDD3pri9j739kBTYckAq8SpTg1mzPxVhQQmD#vJaTXCbxIhNN" +
		"KPJnvshJTvyo7nEnGygpBN#jwq3#qhhGwmimFFGw4cynxhTfryGXnksk5vID41XPYr3cSIo" +
		"MVN$CJ6pscN8RqYx5cJxTcrwQjJwdpedYZfdeAUfSv4z7MpjATQ1A#lcS##mrsjNxfdMl$V" +
		"zYogLQfdDcTx9lpmPCyAvvbjTP6j9P$UWxiyjTRrDc1dbc3csSI2qVXtOSzeAjVYdRbOptX" +
		"d$ZLwvdedwO$gsSynPj7lj9Vk6Orqiz7hGLh$atyZCGZx6h$fo9btCjYBvPrC0lCW$is2Oh" +
		"DH#X$RiKLM7hwdARLZloQrZ2onOui$vBVj2ZNHLqbDsllX7Jk9Aj9K6bLSL$8SOLswv3dYD" +
		"CblzGNoTp43RMll5DIPd##8T5YQRqCKFw4NpYC$HfCkl1ViwfMl7Ah2St7N5hnHB5tZ73gN" +
		"pgFpwGAwCFFpjMBl6KjR2EzWRaNpxufR6xWf8lOmYBIhBNtSs#LJiU4E#jEm5TRWD#3#YFd" +
		"#YQyiivjbtrVs#zd79wLs0k7$eaMtqsLxAZ7#a8pW$PfEzLSGdTdoTMr#JpXxNSkg7cBFnh" +
		"jQkXPfHd5D9J2zqt9CFs9$#4NsF$$fhaJlkeQxkFizd869FUGdFAjRREwpTVCN72rwHjRsE" +
		"LRAlBFPqyRFcbMnDx7z#PoNiepFVwoUNkcwlJcx7pJr$pd68ZccAwdf9#Y9xOR#t4YsAwNd" +
		"vzoRCa#gx9cGSO8eULujpsXJz5F6c5$jIKLFXf#YnK#B$L9kF8EqznE#9zapVBzfFkzhqNk" +
		"xk0xjlzFYTRTAnw#a8$q4bHhHNzONc$4jUelrl#85clDJTD17$rDzAHoRdsT4Cpy1b7pHtp" +
		"kmTNf9N4AFd3ibzPJKCWTxOFepbxlNzMfHd$idtcxBSw$PhtNiNOMEFVThymRQlgzCVM9ly" +
		"UzY#9Rissr6yhYpP6kOTtw3KdhLv9N7BTcwCUyMz8c66qjq2kBestn#bAMMpY$jtzu6PSql" +
		"Q#ddEA5NrLXLuwVLQDddDeMVKBk$1FY5QaNhEdp2CRLQi7zdhybLRNwfDk7vPDuEkxV4RUH" +
		"CAMt7sz6BFBKEj$LZExf8OizPzhtN8BeuyIaNdn7y5tjc$qsyxyxMxlz4IA6zO7M5jORRzr" +
		"Kfkhntr6#6pp4N9y#q#1aHwKt3MCGlCRtXs$QBmxyhhf4nu##IgPBHYklr$9QujLni$5O4K" +
		"$Jfy83u7IEfrNwEwTSOuckbFGeyE2phBOFlNN#i99VrPi9zxdWAPan1ttNy4vEVC1vfthH$" +
		"BLVEBT3lx5jBvCsBx0YOlsIjfylDNgh3jqV2vxJvB8n$Dq1#Ky7$CMzyPGV#TzmpsdqwMvR" +
		"q9XrWlLHcRqkcNlos96MXh#9bJKvdiaJhecLbnJv3Al89TNP9XhyabJVaoHyypr3mfpFaLr" +
		"WwyYhY$rCo3k4mX7O8TsDXvOZwFWt#GFcRGVx$gDHnDkJyVs2#H7eQKNKVeefzm9zFL3uU0" +
		"VAAYr3#Fj9F81#8y6VOsX7fGqXReGpjrIxy$uQ8gZP0#etvdwqLgnELLH5r#ZVH6h2psWv4" +
		"xSz4UZZIPuXwVKVKeGFo5oBz8z8xeAeVqdbeynbaay0l1SOyUE1eUnluBP5#WIvj3XuOsvs" +
		"Bz7capn7LhKFKvqFexW8UhgXxWIY7$kH68i1UVHF2yS3rE32U3Fv9eihEx3Uano9T6pWNWe" +
		"UFWYL4jT#Y$rj31Wnrw5#VCc36tQ3zmN3lTaZl8chL2MNNeJvyskf8y5$8NwDJRdlq7UNju" +
		"OlUlmN$JvHFHte50d$FANnNzZ1m30MU#v3UZ01$v31c5OyHjMv0W9tQrucQVk2lpKJ#GQJy" +
		"7NcVGkSmy8yW787wlP5U2XdwN8anhdmAOHdq$GMu#FkNDqJvJ8pjMqY$8ghfZZ0MxTP7c82" +
		"mEm9ib$yUwGLeYxGSOr5nCVY9q04x5PN0YpbMnjzFEnmf$5VE$m5mBifcG7Txf5S1$yT8xy" +
		"Gura86FS4XiFKYnlDgy1YpMfcxq8jvKuv#LHv7r0ruEsnBj3hmTlW7vYZytE5b#1jZqx4dK" +
		"k3lY7xs6OBqVgIOqxr#XtGKKjmE#q1tB#3gW$dS2pxgyopIrw0RyxuUywLy2wAUpS2y5J3n" +
		"jujYJbRV3lb1a64ySUEaIim1mhpeLWCU$UxxAChustJXXzfka67i#i4NLUoNoz0MFgZ6kDL" +
		"1LrrRX4DH1$Eq5lwenRohmxnh#9weE$z$1FYl3FegCJVAFaAA#Ls9#LE9zLNL2m7zhjeR$h" +
		"aSUh7M#Zq16#XRrNe8Ho70RcTCW6uT4J1dc#2JAioZglVGhpsW1$wec8myvbKrpuLtOHzhf" +
		"#uIp84r8OTVwg2x4cko2ZYgiTQgi9xhqBxxFU2FWGppFeTvceF$SulWDyodUgpb#dCmVbXF" +
		"3PYdZV1v0#PBMun38snrGliwZ67T3S2E#L65$jLWNbTV2rmZW1Dhe0dZrWrzxeuzeXl6lnl" +
		"sZYgqgSQyhiPSha6VgZT3YdvqnbZLeH$1ISZ37zNO9#hUGVtJmME#LKr5YZLVVJRay6iLrc" +
		"VrzGWR8yn7m9vMpV#Pwbz8tq00XchW3U3dcXxW5yF$s8UgiGRAs6OrU1uJ#Bmpva8D#bo3i" +
		"QcjmnXWJ#a7FvHZVrAOZpLSZZsl1laQo6lWmnhCknh#$cNuhWRxKmryMW$Vrs9TrVuLUUmZ" +
		"PV1fBVQtMko5bTX7r7u8y7adxAFzi8xRx8c0iQh1#cor2LACUItytGPhf1O#Q81VQZ7V6Z0" +
		"7QZ7c3Jp7C1VgOAyMzdEOpxNNe1sNOzqrOiwMeuzrsEjgiLPo$P5YJjJ2FutOFsjV0bxqBG" +
		"VxkGEG1zvoz3U7VRG9E3i3Iots#KQCKIl63VztHncUQwWMxMgnFzLXdwp5cBP2l#lGr#vOt" +
		"#NO6#g0fIVyNeUzgotMVXtl8zX$UiBVTLYBjTZNwZ2VMsCjrkqFUy1JWRbJXx78GNyTrd0T" +
		"$D7wBAGOvoRi0PMOTtL7mw$OJpfXx#w7DTKRwwutzfpEc2kry5bhrAl7tAYRGzI5r#8hIB7" +
		"#Mc7kvz2k2$R5LXYl7DPw5wo37EP25$W#znl#wcQaM8jTCIuvZ6zNsEgASIk7tXpso3fU3v" +
		"YthQ0ZXxsi4dPoE4lh0mJueHNscXpsiBROmohGxpgCGMkiXHpcNci#U$w6imbplvAnO1$fY" +
		"pPziG#rWxqg#BCrvdeEyxaTvcbrQ$1OzttXmxxmMGxpjXfxQX$62b#snjwJGxr#qDyEvsCE" +
		"lkkCjTOFPsfhd6yvx3DTiQvgC5$xmN$zC2ygFuUlS0QjZhEnTYUYDU6F6fn5Q$9$70R6pbY" +
		"ZkTqGi5SGzc32sgd1FAl1VCbXhmZUHifh0ljrxM3mc3$rs4zpq5k$C$eB$FKOithu9eSpfm" +
		"ppfW9ZLejzenR#p66Er09B3SQc5kkj5caTnZU7jLk7SSknN$w0W3j23djRxYO4#BGUvsrFd" +
		"2#zCMUwdKVKurxaCK$hiHTqMmrrLY1WRjPZ$sp3Um3MPptsmNhCAVxYndBS1#hXtzxmJpty" +
		"K0yCzUkYtzl0xzWxwby55ko7zS3GWmFEltg4LlKuipS53x$K3qBO5$gnfZhndeWplWlMSJt" +
		"sj2wyF#8CQCDx6SwyUenp8#kunDp1QXjC6ZIPb6euDNpv8Out#GvzECMnEDRSimB#hrVAjj" +
		"yfgaV3$NPP0KsdHtpZgIdbEPEs6MNIjckQjETTrkPgKTsoOoE##vScxVQ59xlMfBrkZsJ1d" +
		"D8OUw#8#DLNjod$pqfhO$KTRChducBB7vxGuTbSRM74zthArXyPoTgi5MzRTer9QLEJgiyy" +
		"F1SMucryeL3MvYMJbhyMoHhMZDS9catQUVza#tWzsZlYA#w8#CepRVfg95CFHNpFWmjrhNv" +
		"rkesgtsVRx$sMIVjMcBGiC6cFTKowsZoJzdhGzbbRN3VQ$XrgqkxJRRlTFJntM9rOBnNdH7" +
		"8#Dsc3A5$zGSJN76xxYcUHCkmFvJW$Ah5$LM6VAySPLBuHrjW#MVtnR61Fgy1UKudzjdfFi" +
		"svhiVzKdf1Ul#FZyJpV3SlNj$XnzfV1VYNVLQxoS4DUkpZUjtBiMnNOHyfn3wXcUzYJQ$c#" +
		"kw67RRvjptic$yS7dBkLBtb#crQwVrKuSwlWbmhSFskm5rREADMc1JfnPwcyWvyLJBu7#bl" +
		"LQCk6HlKgSC#j#aUKB#iSrwE65EgktjgabSzasw$5ML0zByfNulxJ5S#cjRSNrgrPrwJTwo" +
		"FPwlFYTNflxUdUCUAxVM$IdlvSNSJtmsB#yVeoqsAei#c9KLd3wPuVSEUe#J3ULjsIo7$lz" +
		"SdVYvRQ$k5kN7QVxSDQKVaQzfpeZdjAcLsJtP#9ogjFjxA59gtRnxQpuzc3lurZYYtBUtfx" +
		"stBCxU0eMuxxIOyjcKURr$bizkfZFTONx3kGJOduLhN9yc81Fvj5V1dcUQjj35zP5g$Nohx" +
		"tQEmBZ5six1wRlc$IXXUZ#dtmRDYNlvVs0PDlNMLITP1N1$VlljV3Vz$Q$2HRTo#JziKzQ8" +
		"tjBO$dcBxBKJOwZgildalwvYsFSwmVxd$zSE$gSabKfnnpe$eK1BIl6cxUOTJmVMwYLyUEO" +
		"Uixu$fhpx3ooP4iXpjGpPFcsQyBdXLos1DoE$djVammxmBAi4TrgJJvcW$CCqtLVUO#pEzQ" +
		"Aju5bcSjDZoBvQuplDmFyQnIXUUVt4pp7gOIvQrnbwy$8DtU6dibxCF7rMjauojlZEVvHms" +
		"aRqaX11Bu$of#ZFod29yX$ndIBwcCtWB$5l5t$0SqcgeHSWYrDl3tR9lmjeGoUWBrbfFvFi" +
		"AhlN2D3IyLX213PkGF8toDi0pX7eJB4IOZJ4NvLDZ3ReYW40AQY7GYqkkHcX3OOFBpgO9M4" +
		"7$7MK1VKIL2ELs2z19v6nlOK8VGIlZnqFzFrBaKgGaLT3RInT2n6EcJI3bCaL163w3y6xIx" +
		"5daE4y1pkDa6p184XH3GRKWvt0h#AWbbD0hfAAHB85#2z2deCo67K8vGXr29K8#Ww1RKvsy" +
		"#F0TrpW4VXMg4AeGoUjs61s7xGTGz3#tlHte$P9E8$oD4GEUZxdFGSIxIUKZdGNOAqbCaBR" +
		"CXI0H5fq7NQU3V0Fy6wl3RqwV1$mrj$mQy2y0lW7mcmaBK#pjaxqFsFlAp44v7#pUHFmFfS" +
		"KWvd82s$v4GqF787uzwnoD$B58J0lblBCU0Jm#AZaRuguIoM3WAigCaZS8Ha1q1dHoE17ya" +
		"P1mE0vyTohmqgdie#dSdiDu9NNCXdmkPI$blecwNK4Pt8ELm8$YRa7uaeOpc89s3z77Yjsq" +
		"AeOnc8vqjtz4Qq4dW#VjQ#Jiv3qVu2#mTWfI$nVnWf0UZR2dIfKWFWkmPy3Ca17GNKWxZg4" +
		"p2Ev2TYVoPI4z5UYhn$olXxzzMT2BiduWKknY28knS28hu2MmiKlu$tYyWnLCdWYB#psMV8" +
		"#MtdsE8$$i88IZY$yp#8j8haLw9z56aZoBb$ot5$qlgEkB$RwS8koI28jmk41JnMy4FaLw0" +
		"z0Aa5qe822SJWY8ydI8eVckFeFWD8e8Yt2eH5F5$K7iUAPxM4HJnVyX#XVZxKGb14Mu32Fm" +
		"VZWX1oN#aFGlfyFy7KCQEHG==");
 // Generated from /home/hobbypunk/Dokumente/Entwicklung/THM_Projekte/Projektphase/jModelica/build/java/src/java-generated/org/jmodelica/modelica/parser/ModelicaParser.parser
/**
     * Error reporting class that creates an error message and delegates reporting the 
     * message to a subclass.
     */
    public abstract static class Report extends Events {

        /**
         * Report an error with error message <code>msg</code>.
         */
        protected abstract void report(Problem P);

        /**
         * Creates an error message for when <code>token</code> is found unexpectedly. 
         * Passes the error message to {@link #report(Problem)}.
         * @param token     the unexpected symbol.
         */
        public void syntaxError(Symbol token) {
            
            StringBuilder s = new StringBuilder();
            //s.append("Syntax error at line "+ Symbol.getLine(token.getStart()) + ", column " + Symbol.getColumn(token.getStart()) + "\n");
            if (token.value != null) {
                s.append("   Unexpected token: \"" + token.value + "\"");
            } else if (token.getId()<Terminals.NAMES.length)
                s.append("  Unexpected token: " + Terminals.NAMES[token.getId()]);
            else 
                s.append("  Syntactic error");
            Problem p = new Problem(fileName, s.toString(), ProblemSeverity.ERROR, ProblemKind.SYNTACTIC, Symbol.getLine(token.getStart()), Symbol.getColumn(token.getStart()));
            
            report(p);
        }

        /**
         * Creates an error message for when the scanner throws an exception.
         * Passes the error message to {@link #report(Problem)}.
         * @param e     the exception.
         */
        public void scannerError(Scanner.Exception e) {
            /*
            StringBuilder s = new StringBuilder(e.getMessage());
            s.append(" at line ");
            s.append(e.line);
            s.append(", column ");
            s.append(e.column);
            */
            Problem p = new Problem(fileName, e.getMessage(), ProblemSeverity.ERROR, ProblemKind.LEXICAL, e.line, e.column);
            
            report(p);
        }

        private String fileName = "";

        public void setFileName(String fn) {
            fileName = fn;
        }

    }
    
    /**
     * Error reporting class that throws a {@link ParserException} on an error.
     * Uses error message created by {@link Report}.
     */
    public class AbortingReport extends Report {

        /**
         * Throws a <code>ParserException</code> with <code>msg</code> as the message.
         */
        @Override
        protected void report(Problem p) {
          throw new ParserException(p);
        }

    }

    /**
     * Error reporting class that collects error messages for later retrieval.
     * Uses error message created by {@link Report}.
     */
    public static class CollectingReport extends Report {

        private ArrayList<Problem> errors = new ArrayList<Problem>();

        /**
         * Adds error message <code>msg</code> to list.
         */ 
        @Override
        protected void report(Problem p) {
            errors.add(p);          
        }

        /**
         * Get the list of errors. Returns a reference to the internal list, not a copy.
         * @return a {@link Collection} with the reported error messages.
         */
        public Collection<Problem> getErrors() {
            return errors;
        }

        /**
         * Reset the list of errors.
         */
        public void resetErrors() {
            errors = new ArrayList<Problem>();
        }

        /**
         * Checks if any errors has been reported.
         * @return <code>true</code> if the list contains any errors.
         */
        public boolean hasErrors() {
            return !errors.isEmpty();
        }

    }

    { report = new AbortingReport(); }  // As default, throw exception on errors.

    /**
     * Set the error reporting class to use.
     * @param report    a subclass of {@link Events} to use for reporting errors.
     */
    public void setReport(Events report) {
        this.report = report;
    }

    public Events getReport() {
        return report;
    }

    private int[] lineBreakMap;

    public void setLineBreakMap(int[] map) {
        lineBreakMap = map;
    }

    private FormattingInfo formatting;

    public void setFormattingInfo(FormattingInfo formatting) {
        this.formatting = formatting;
    }

    public void setFileName(String fn) {
        if (report instanceof Report)
            ((Report) report).setFileName(fn);
    }
    
    Symbol annotationTok = null;

	public ModelicaParser() {
		super(PARSING_TABLES);
	}

	protected Symbol invokeReduceAction(int rule_num, int offset) {
		switch(rule_num) {
			case 3: // source_root = 
			{
					 SourceRoot sr = new SourceRoot(new Program(new List()));
        return sr;
			}
			case 4: // source_root = program.program
			{
					final Symbol _symbol_program = _symbols[offset + 1];
					final Program program = (Program) _symbol_program.value;
					 SourceRoot sr = new SourceRoot(program); 
       return sr;
			}
			case 5: // program = stored_definition.stored_definition
			{
					final Symbol _symbol_stored_definition = _symbols[offset + 1];
					final StoredDefinition stored_definition = (StoredDefinition) _symbol_stored_definition.value;
					 return new Program(new List().add(stored_definition));
			}
			case 6: // stored_definition = within_opt.within base_class_decl_list.base_class_decl_list
			{
					final Symbol _symbol_within = _symbols[offset + 1];
					final Opt within = (Opt) _symbol_within.value;
					final Symbol _symbol_base_class_decl_list = _symbols[offset + 2];
					final List base_class_decl_list = (List) _symbol_base_class_decl_list.value;
					 StoredDefinition def = new StoredDefinition(within, base_class_decl_list);
        def.setLineBreakMap(lineBreakMap);
        def.setFormatting(formatting);
    	return def;
			}
			case 7: // stored_definition = error.error
			{
					final Symbol error = _symbols[offset + 1];
					 return new BadDefinition();
			}
			case 8: // within = WITHIN.WITHIN parse_access_opt.parse_access SEMICOLON.SEMICOLON
			{
					final Symbol WITHIN = _symbols[offset + 1];
					final Symbol _symbol_parse_access = _symbols[offset + 2];
					final Opt parse_access = (Opt) _symbol_parse_access.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new Within(parse_access);
			}
			case 9: // base_class_decl_list = base_class_decl.base_class_decl SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_base_class_decl = _symbols[offset + 1];
					final BaseClassDecl base_class_decl = (BaseClassDecl) _symbol_base_class_decl.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new List().add(base_class_decl);
			}
			case 10: // base_class_decl_list = base_class_decl_list.base_class_decl_list base_class_decl.base_class_decl SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_base_class_decl_list = _symbols[offset + 1];
					final List base_class_decl_list = (List) _symbol_base_class_decl_list.value;
					final Symbol _symbol_base_class_decl = _symbols[offset + 2];
					final BaseClassDecl base_class_decl = (BaseClassDecl) _symbol_base_class_decl.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 base_class_decl_list.add(base_class_decl);
        return base_class_decl_list;
			}
			case 11: // anonymous_short_class = class_access.class_access class_modification_opt.class_modification
			{
					final Symbol _symbol_class_access = _symbols[offset + 1];
					final Access class_access = (Access) _symbol_class_access.value;
					final Symbol _symbol_class_modification = _symbols[offset + 2];
					final Opt class_modification = (Opt) _symbol_class_modification.value;
					 return new PN_ShortClassDecl(
                   new IdDecl("'Anonymous Class'"),
                   new UnknownVisibilityType(),
                   new Opt(), new Opt(), 
                   new MClass(), 
                   new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), 
                   new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), 
                   class_access,
                   new Opt(), 
                   class_modification, 
                   new Comment());
			}
			case 12: // base_class_decl = encapsulated_opt.encapsulated partial_opt.partial restriction.restriction id_decl.start string_comment_opt.string_comment composition.composition annotation_sc_opt.annotation_sc end_decl.end_decl
			{
					final Symbol _symbol_encapsulated = _symbols[offset + 1];
					final Opt encapsulated = (Opt) _symbol_encapsulated.value;
					final Symbol _symbol_partial = _symbols[offset + 2];
					final Opt partial = (Opt) _symbol_partial.value;
					final Symbol _symbol_restriction = _symbols[offset + 3];
					final Restriction restriction = (Restriction) _symbol_restriction.value;
					final Symbol _symbol_start = _symbols[offset + 4];
					final IdDecl start = (IdDecl) _symbol_start.value;
					final Symbol _symbol_string_comment = _symbols[offset + 5];
					final Opt string_comment = (Opt) _symbol_string_comment.value;
					final Symbol _symbol_composition = _symbols[offset + 6];
					final Composition composition = (Composition) _symbol_composition.value;
					final Symbol _symbol_annotation_sc = _symbols[offset + 7];
					final Opt annotation_sc = (Opt) _symbol_annotation_sc.value;
					final Symbol _symbol_end_decl = _symbols[offset + 8];
					final EndDecl end_decl = (EndDecl) _symbol_end_decl.value;
					 return new PN_FullClassDecl(
            start,
            new UnknownVisibilityType(),
            encapsulated,
            partial,
            restriction,
            new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(),
            string_comment,
            composition,
            annotation_sc,
            end_decl);
			}
			case 13: // base_class_decl = encapsulated_opt.encapsulated partial_opt.partial restriction.restriction id_decl.class_name EQUALS.EQUALS type_prefix_flow_opt.type_prefix_flow type_prefix_variability_opt.type_prefix_variability type_prefix_input_output_opt.type_prefix_input_output class_access.class_access array_subscripts_opt.array_subscripts class_modification_opt.class_modification comment.comment
			{
					final Symbol _symbol_encapsulated = _symbols[offset + 1];
					final Opt encapsulated = (Opt) _symbol_encapsulated.value;
					final Symbol _symbol_partial = _symbols[offset + 2];
					final Opt partial = (Opt) _symbol_partial.value;
					final Symbol _symbol_restriction = _symbols[offset + 3];
					final Restriction restriction = (Restriction) _symbol_restriction.value;
					final Symbol _symbol_class_name = _symbols[offset + 4];
					final IdDecl class_name = (IdDecl) _symbol_class_name.value;
					final Symbol EQUALS = _symbols[offset + 5];
					final Symbol _symbol_type_prefix_flow = _symbols[offset + 6];
					final Opt type_prefix_flow = (Opt) _symbol_type_prefix_flow.value;
					final Symbol _symbol_type_prefix_variability = _symbols[offset + 7];
					final Opt type_prefix_variability = (Opt) _symbol_type_prefix_variability.value;
					final Symbol _symbol_type_prefix_input_output = _symbols[offset + 8];
					final Opt type_prefix_input_output = (Opt) _symbol_type_prefix_input_output.value;
					final Symbol _symbol_class_access = _symbols[offset + 9];
					final Access class_access = (Access) _symbol_class_access.value;
					final Symbol _symbol_array_subscripts = _symbols[offset + 10];
					final Opt array_subscripts = (Opt) _symbol_array_subscripts.value;
					final Symbol _symbol_class_modification = _symbols[offset + 11];
					final Opt class_modification = (Opt) _symbol_class_modification.value;
					final Symbol _symbol_comment = _symbols[offset + 12];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new PN_ShortClassDecl(
            class_name, 
            new UnknownVisibilityType(),
            encapsulated, 
            partial, 
            restriction, 
            new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(),
            type_prefix_flow, 
            type_prefix_variability, 
            type_prefix_input_output, 
            class_access,
            array_subscripts, 
            class_modification, 
            comment);
			}
			case 14: // base_class_decl = encapsulated_opt.encapsulated partial_opt.partial restriction.restriction EXTENDS.EXTENDS id_decl.start class_modification_opt.class_modification string_comment_opt.string_comment composition.composition annotation_sc_opt.annotation_sc end_decl.end_decl
			{
					final Symbol _symbol_encapsulated = _symbols[offset + 1];
					final Opt encapsulated = (Opt) _symbol_encapsulated.value;
					final Symbol _symbol_partial = _symbols[offset + 2];
					final Opt partial = (Opt) _symbol_partial.value;
					final Symbol _symbol_restriction = _symbols[offset + 3];
					final Restriction restriction = (Restriction) _symbol_restriction.value;
					final Symbol EXTENDS = _symbols[offset + 4];
					final Symbol _symbol_start = _symbols[offset + 5];
					final IdDecl start = (IdDecl) _symbol_start.value;
					final Symbol _symbol_class_modification = _symbols[offset + 6];
					final Opt class_modification = (Opt) _symbol_class_modification.value;
					final Symbol _symbol_string_comment = _symbols[offset + 7];
					final Opt string_comment = (Opt) _symbol_string_comment.value;
					final Symbol _symbol_composition = _symbols[offset + 8];
					final Composition composition = (Composition) _symbol_composition.value;
					final Symbol _symbol_annotation_sc = _symbols[offset + 9];
					final Opt annotation_sc = (Opt) _symbol_annotation_sc.value;
					final Symbol _symbol_end_decl = _symbols[offset + 10];
					final EndDecl end_decl = (EndDecl) _symbol_end_decl.value;
					 return new PN_ExtendClassDecl(
            start,
            new UnknownVisibilityType(),
            encapsulated,
            partial,
            restriction,
            new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(),
            string_comment,
            composition,
            annotation_sc,
            end_decl, 
            class_modification);
			}
			case 15: // base_class_decl = encapsulated_opt.encapsulated partial_opt.partial restriction.restriction id_decl.enum_name EQUALS.EQUALS ENUMERATION.ENUMERATION LPAREN.LPAREN enum_specification.enum_specification RPAREN.RPAREN comment.comment
			{
					final Symbol _symbol_encapsulated = _symbols[offset + 1];
					final Opt encapsulated = (Opt) _symbol_encapsulated.value;
					final Symbol _symbol_partial = _symbols[offset + 2];
					final Opt partial = (Opt) _symbol_partial.value;
					final Symbol _symbol_restriction = _symbols[offset + 3];
					final Restriction restriction = (Restriction) _symbol_restriction.value;
					final Symbol _symbol_enum_name = _symbols[offset + 4];
					final IdDecl enum_name = (IdDecl) _symbol_enum_name.value;
					final Symbol EQUALS = _symbols[offset + 5];
					final Symbol ENUMERATION = _symbols[offset + 6];
					final Symbol LPAREN = _symbols[offset + 7];
					final Symbol _symbol_enum_specification = _symbols[offset + 8];
					final EnumSpecification enum_specification = (EnumSpecification) _symbol_enum_specification.value;
					final Symbol RPAREN = _symbols[offset + 9];
					final Symbol _symbol_comment = _symbols[offset + 10];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new PN_EnumDecl(
            enum_name,
            new UnknownVisibilityType(),
            encapsulated,
            partial,
            restriction,
            new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(), new Opt(),
            ENUMERATION,
            enum_specification,
            comment);
			}
			case 16: // base_class_decl = error.error
			{
					final Symbol error = _symbols[offset + 1];
					 return new BadClassDecl();
			}
			case 17: // enum_specification = COLON.COLON
			{
					final Symbol COLON = _symbols[offset + 1];
					 return new EnumUnspecified();
			}
			case 18: // enum_specification = enum_literal_list.enum_literal_list
			{
					final Symbol _symbol_enum_literal_list = _symbols[offset + 1];
					final List enum_literal_list = (List) _symbol_enum_literal_list.value;
					 return new EnumLiteralList(enum_literal_list);
			}
			case 19: // enum_literal_list = enum_literal.enum_literal
			{
					final Symbol _symbol_enum_literal = _symbols[offset + 1];
					final EnumLiteral enum_literal = (EnumLiteral) _symbol_enum_literal.value;
					 return new List().add(enum_literal);
			}
			case 20: // enum_literal_list = enum_literal_list.enum_literal_list COMMA.COMMA enum_literal.enum_literal
			{
					final Symbol _symbol_enum_literal_list = _symbols[offset + 1];
					final List enum_literal_list = (List) _symbol_enum_literal_list.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_enum_literal = _symbols[offset + 3];
					final EnumLiteral enum_literal = (EnumLiteral) _symbol_enum_literal.value;
					 enum_literal_list.add(enum_literal); 
                                       return enum_literal_list;
			}
			case 21: // enum_literal = id_decl.id_decl comment.comment
			{
					final Symbol _symbol_id_decl = _symbols[offset + 1];
					final IdDecl id_decl = (IdDecl) _symbol_id_decl.value;
					final Symbol _symbol_comment = _symbols[offset + 2];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new EnumLiteral(id_decl,comment);
			}
			case 22: // partial = PARTIAL.PARTIAL
			{
					final Symbol PARTIAL = _symbols[offset + 1];
					 return new Partial();
			}
			case 23: // encapsulated = ENCAPSULATED.ENCAPSULATED
			{
					final Symbol ENCAPSULATED = _symbols[offset + 1];
					 return new Encapsulated();
			}
			case 24: // type_prefix_variability = DISCRETE.DISCRETE
			{
					final Symbol DISCRETE = _symbols[offset + 1];
					 return new Discrete();
			}
			case 25: // type_prefix_variability = PARAMETER.PARAMETER
			{
					final Symbol PARAMETER = _symbols[offset + 1];
					 return new Parameter();
			}
			case 26: // type_prefix_variability = CONSTANT.CONSTANT
			{
					final Symbol CONSTANT = _symbols[offset + 1];
					 return new Constant();
			}
			case 27: // type_prefix_input_output = INPUT.INPUT
			{
					final Symbol INPUT = _symbols[offset + 1];
					 return new Input();
			}
			case 28: // type_prefix_input_output = OUTPUT.OUTPUT
			{
					final Symbol OUTPUT = _symbols[offset + 1];
					 return new Output();
			}
			case 29: // restriction = CLASS.CLASS
			{
					final Symbol CLASS = _symbols[offset + 1];
					 return new MClass();
			}
			case 30: // restriction = MODEL.MODEL
			{
					final Symbol MODEL = _symbols[offset + 1];
					 return new Model();
			}
			case 31: // restriction = BLOCK.BLOCK
			{
					final Symbol BLOCK = _symbols[offset + 1];
					 return new Block();
			}
			case 32: // restriction = CONNECTOR.CONNECTOR
			{
					final Symbol CONNECTOR = _symbols[offset + 1];
					 return new Connector();
			}
			case 33: // restriction = EXPANDABLE.EXPANDABLE CONNECTOR.CONNECTOR
			{
					final Symbol EXPANDABLE = _symbols[offset + 1];
					final Symbol CONNECTOR = _symbols[offset + 2];
					 return new ExpandableConnector();
			}
			case 34: // restriction = TYPE.TYPE
			{
					final Symbol TYPE = _symbols[offset + 1];
					 return new MType();
			}
			case 35: // restriction = PACKAGE.PACKAGE
			{
					final Symbol PACKAGE = _symbols[offset + 1];
					 return new MPackage();
			}
			case 36: // restriction = FUNCTION.FUNCTION
			{
					final Symbol FUNCTION = _symbols[offset + 1];
					 return new Function();
			}
			case 37: // restriction = RECORD.RECORD
			{
					final Symbol RECORD = _symbols[offset + 1];
					 return new Record();
			}
			case 38: // restriction = OPERATOR.OPERATOR RECORD.RECORD
			{
					final Symbol OPERATOR = _symbols[offset + 1];
					final Symbol RECORD = _symbols[offset + 2];
					 return new OperatorRecord();
			}
			case 39: // restriction = OPERATOR.OPERATOR FUNCTION.FUNCTION
			{
					final Symbol OPERATOR = _symbols[offset + 1];
					final Symbol FUNCTION = _symbols[offset + 2];
					 return new OperatorFunction();
			}
			case 40: // restriction = OPERATOR.OPERATOR
			{
					final Symbol OPERATOR = _symbols[offset + 1];
					 return new Operator();
			}
			case 41: // final_ = FINAL.FINAL
			{
					final Symbol FINAL = _symbols[offset + 1];
					 return new Final();
			}
			case 42: // inner = INNER.INNER
			{
					final Symbol INNER = _symbols[offset + 1];
					 return new Inner();
			}
			case 43: // outer = OUTER.OUTER
			{
					final Symbol OUTER = _symbols[offset + 1];
					 return new Outer();
			}
			case 44: // replaceable = REPLACEABLE.REPLACEABLE
			{
					final Symbol REPLACEABLE = _symbols[offset + 1];
					 return new Replaceable();
			}
			case 45: // redeclare = REDECLARE.REDECLARE
			{
					final Symbol REDECLARE = _symbols[offset + 1];
					 return new Redeclare();
			}
			case 46: // each = EACH.EACH
			{
					final Symbol EACH = _symbols[offset + 1];
					 return new Each();
			}
			case 47: // composition = composition_clauses.composition_clauses external_clause_opt.external_clause
			{
					final Symbol _symbol_composition_clauses = _symbols[offset + 1];
					final List composition_clauses = (List) _symbol_composition_clauses.value;
					final Symbol _symbol_external_clause = _symbols[offset + 2];
					final Opt external_clause = (Opt) _symbol_external_clause.value;
					 return new Composition(composition_clauses,external_clause);
			}
			case 48: // composition = elements.elements composition_clauses.composition_clauses external_clause_opt.external_clause
			{
					final Symbol _symbol_elements = _symbols[offset + 1];
					final List elements = (List) _symbol_elements.value;
					final Symbol _symbol_composition_clauses = _symbols[offset + 2];
					final List composition_clauses = (List) _symbol_composition_clauses.value;
					final Symbol _symbol_external_clause = _symbols[offset + 3];
					final Opt external_clause = (Opt) _symbol_external_clause.value;
					 composition_clauses.insertChild(new PublicElementList(elements), 0);
                  return new Composition(composition_clauses, external_clause);
			}
			case 49: // composition_clauses = 
			{
					 return new List();
			}
			case 50: // composition_clauses = composition_clause.composition_clause
			{
					final Symbol _symbol_composition_clause = _symbols[offset + 1];
					final Clause composition_clause = (Clause) _symbol_composition_clause.value;
					 return new List().add(composition_clause);
			}
			case 51: // composition_clauses = composition_clauses.composition_clauses composition_clause.composition_clause
			{
					final Symbol _symbol_composition_clauses = _symbols[offset + 1];
					final List composition_clauses = (List) _symbol_composition_clauses.value;
					final Symbol _symbol_composition_clause = _symbols[offset + 2];
					final Clause composition_clause = (Clause) _symbol_composition_clause.value;
					 return composition_clauses.add(composition_clause);
			}
			case 52: // elements = element.element
			{
					final Symbol _symbol_element = _symbols[offset + 1];
					final Element element = (Element) _symbol_element.value;
					 return new List().add(element);
			}
			case 53: // elements = elements.elements element.element
			{
					final Symbol _symbol_elements = _symbols[offset + 1];
					final List elements = (List) _symbol_elements.value;
					final Symbol _symbol_element = _symbols[offset + 2];
					final Element element = (Element) _symbol_element.value;
					 return elements.add(element);
			}
			case 54: // composition_clause = PUBLIC.PUBLIC
			{
					final Symbol PUBLIC = _symbols[offset + 1];
					 return new PublicElementList(new List());
			}
			case 55: // composition_clause = PROTECTED.PROTECTED
			{
					final Symbol PROTECTED = _symbols[offset + 1];
					 return new ProtectedElementList(new List());
			}
			case 56: // composition_clause = PUBLIC.PUBLIC elements.elements
			{
					final Symbol PUBLIC = _symbols[offset + 1];
					final Symbol _symbol_elements = _symbols[offset + 2];
					final List elements = (List) _symbol_elements.value;
					 return new PublicElementList(elements);
			}
			case 57: // composition_clause = PROTECTED.PROTECTED elements.elements
			{
					final Symbol PROTECTED = _symbols[offset + 1];
					final Symbol _symbol_elements = _symbols[offset + 2];
					final List elements = (List) _symbol_elements.value;
					 return new ProtectedElementList(elements);
			}
			case 58: // composition_clause = equation_clause.equation_clause
			{
					final Symbol _symbol_equation_clause = _symbols[offset + 1];
					final EquationClause equation_clause = (EquationClause) _symbol_equation_clause.value;
					 return equation_clause;
			}
			case 59: // composition_clause = algorithm.algorithm
			{
					final Symbol _symbol_algorithm = _symbols[offset + 1];
					final Algorithm algorithm = (Algorithm) _symbol_algorithm.value;
					 return algorithm;
			}
			case 60: // external_clause = EXTERNAL.EXTERNAL external_language_opt.external_language external_function_call_opt.external_function_call annotation_opt.a1 SEMICOLON.SEMICOLON
			{
					final Symbol EXTERNAL = _symbols[offset + 1];
					final Symbol _symbol_external_language = _symbols[offset + 2];
					final Opt external_language = (Opt) _symbol_external_language.value;
					final Symbol _symbol_external_function_call = _symbols[offset + 3];
					final Opt external_function_call = (Opt) _symbol_external_function_call.value;
					final Symbol _symbol_a1 = _symbols[offset + 4];
					final Opt a1 = (Opt) _symbol_a1.value;
					final Symbol SEMICOLON = _symbols[offset + 5];
					 return new ExternalClause(external_language, external_function_call, a1);
			}
			case 61: // external_language = STRING.s
			{
					final Symbol s = _symbols[offset + 1];
					 return new ExternalLanguage(((String)s.value));
			}
			case 62: // annotation_sc = annotation.annotation SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_annotation = _symbols[offset + 1];
					final Annotation annotation = (Annotation) _symbol_annotation.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return annotation;
			}
			case 63: // external_function_call = parse_access.parse_access EQUALS.EQUALS id_decl.id_decl LPAREN.LPAREN arg_list.arg_list RPAREN.RPAREN
			{
					final Symbol _symbol_parse_access = _symbols[offset + 1];
					final Access parse_access = (Access) _symbol_parse_access.value;
					final Symbol EQUALS = _symbols[offset + 2];
					final Symbol _symbol_id_decl = _symbols[offset + 3];
					final IdDecl id_decl = (IdDecl) _symbol_id_decl.value;
					final Symbol LPAREN = _symbols[offset + 4];
					final Symbol _symbol_arg_list = _symbols[offset + 5];
					final List arg_list = (List) _symbol_arg_list.value;
					final Symbol RPAREN = _symbols[offset + 6];
					 return new ExternalFunctionCall(new Opt(parse_access), id_decl, arg_list);
			}
			case 64: // external_function_call = id_decl.id_decl LPAREN.LPAREN arg_list.arg_list RPAREN.RPAREN
			{
					final Symbol _symbol_id_decl = _symbols[offset + 1];
					final IdDecl id_decl = (IdDecl) _symbol_id_decl.value;
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_arg_list = _symbols[offset + 3];
					final List arg_list = (List) _symbol_arg_list.value;
					final Symbol RPAREN = _symbols[offset + 4];
					 return new ExternalFunctionCall(new Opt(), id_decl, arg_list);
			}
			case 65: // element = redeclare_opt.redeclare final__opt.final_ inner_opt.inner outer_opt.outer base_class_decl.base_class_decl SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_redeclare = _symbols[offset + 1];
					final Opt redeclare = (Opt) _symbol_redeclare.value;
					final Symbol _symbol_final_ = _symbols[offset + 2];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_inner = _symbols[offset + 3];
					final Opt inner = (Opt) _symbol_inner.value;
					final Symbol _symbol_outer = _symbols[offset + 4];
					final Opt outer = (Opt) _symbol_outer.value;
					final Symbol _symbol_base_class_decl = _symbols[offset + 5];
					final BaseClassDecl base_class_decl = (BaseClassDecl) _symbol_base_class_decl.value;
					final Symbol SEMICOLON = _symbols[offset + 6];
					 base_class_decl.setRedeclareOpt(redeclare);
        base_class_decl.setFinalOpt(final_);   
        base_class_decl.setInnerOpt(inner);
        base_class_decl.setOuterOpt(outer);
        return base_class_decl;
			}
			case 66: // element = redeclare_opt.redeclare final__opt.final_ inner_opt.inner outer_opt.outer replaceable.replaceable base_class_decl.base_class_decl constraining_clause_opt.constraining_clause comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_redeclare = _symbols[offset + 1];
					final Opt redeclare = (Opt) _symbol_redeclare.value;
					final Symbol _symbol_final_ = _symbols[offset + 2];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_inner = _symbols[offset + 3];
					final Opt inner = (Opt) _symbol_inner.value;
					final Symbol _symbol_outer = _symbols[offset + 4];
					final Opt outer = (Opt) _symbol_outer.value;
					final Symbol _symbol_replaceable = _symbols[offset + 5];
					final Replaceable replaceable = (Replaceable) _symbol_replaceable.value;
					final Symbol _symbol_base_class_decl = _symbols[offset + 6];
					final BaseClassDecl base_class_decl = (BaseClassDecl) _symbol_base_class_decl.value;
					final Symbol _symbol_constraining_clause = _symbols[offset + 7];
					final Opt constraining_clause = (Opt) _symbol_constraining_clause.value;
					final Symbol _symbol_comment = _symbols[offset + 8];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 9];
					 base_class_decl.setRedeclareOpt(redeclare);
        base_class_decl.setFinalOpt(final_);   
        base_class_decl.setInnerOpt(inner);
        base_class_decl.setOuterOpt(outer);
        base_class_decl.setReplaceableOpt(new Opt(replaceable));
        base_class_decl.setConstrainingClauseOpt(constraining_clause);
        base_class_decl.setConstrainingClauseComment(comment);
        return base_class_decl;
			}
			case 67: // element = extends_clause.extends_clause SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_extends_clause = _symbols[offset + 1];
					final PN_ExtendsClause extends_clause = (PN_ExtendsClause) _symbol_extends_clause.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return extends_clause;
			}
			case 68: // element = import_clause.import_clause SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_import_clause = _symbols[offset + 1];
					final ImportClause import_clause = (ImportClause) _symbol_import_clause.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return import_clause;
			}
			case 69: // element = redeclare_opt.redeclare final__opt.final_ inner_opt.inner outer_opt.outer type_prefix_flow_opt.type_prefix_flow type_prefix_variability_opt.type_prefix_variability type_prefix_input_output_opt.type_prefix_input_output class_access.class_access array_subscripts_opt.array_subscripts component_list.component_list SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_redeclare = _symbols[offset + 1];
					final Opt redeclare = (Opt) _symbol_redeclare.value;
					final Symbol _symbol_final_ = _symbols[offset + 2];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_inner = _symbols[offset + 3];
					final Opt inner = (Opt) _symbol_inner.value;
					final Symbol _symbol_outer = _symbols[offset + 4];
					final Opt outer = (Opt) _symbol_outer.value;
					final Symbol _symbol_type_prefix_flow = _symbols[offset + 5];
					final Opt type_prefix_flow = (Opt) _symbol_type_prefix_flow.value;
					final Symbol _symbol_type_prefix_variability = _symbols[offset + 6];
					final Opt type_prefix_variability = (Opt) _symbol_type_prefix_variability.value;
					final Symbol _symbol_type_prefix_input_output = _symbols[offset + 7];
					final Opt type_prefix_input_output = (Opt) _symbol_type_prefix_input_output.value;
					final Symbol _symbol_class_access = _symbols[offset + 8];
					final Access class_access = (Access) _symbol_class_access.value;
					final Symbol _symbol_array_subscripts = _symbols[offset + 9];
					final Opt array_subscripts = (Opt) _symbol_array_subscripts.value;
					final Symbol _symbol_component_list = _symbols[offset + 10];
					final List component_list = (List) _symbol_component_list.value;
					final Symbol SEMICOLON = _symbols[offset + 11];
					 return new PN_ComponentClause(
            redeclare,
            final_,
            inner,
            outer,
            new Opt(),
            type_prefix_flow,
            type_prefix_variability,
            type_prefix_input_output,
            class_access,
            array_subscripts,
            component_list,
            new Opt(),
            new Comment(new Opt(), new Opt()));
			}
			case 70: // element = redeclare_opt.redeclare final__opt.final_ inner_opt.inner outer_opt.outer replaceable.replaceable type_prefix_flow_opt.type_prefix_flow type_prefix_variability_opt.type_prefix_variability type_prefix_input_output_opt.type_prefix_input_output class_access.class_access array_subscripts_opt.array_subscripts component_list.component_list constraining_clause_opt.constraining_clause comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_redeclare = _symbols[offset + 1];
					final Opt redeclare = (Opt) _symbol_redeclare.value;
					final Symbol _symbol_final_ = _symbols[offset + 2];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_inner = _symbols[offset + 3];
					final Opt inner = (Opt) _symbol_inner.value;
					final Symbol _symbol_outer = _symbols[offset + 4];
					final Opt outer = (Opt) _symbol_outer.value;
					final Symbol _symbol_replaceable = _symbols[offset + 5];
					final Replaceable replaceable = (Replaceable) _symbol_replaceable.value;
					final Symbol _symbol_type_prefix_flow = _symbols[offset + 6];
					final Opt type_prefix_flow = (Opt) _symbol_type_prefix_flow.value;
					final Symbol _symbol_type_prefix_variability = _symbols[offset + 7];
					final Opt type_prefix_variability = (Opt) _symbol_type_prefix_variability.value;
					final Symbol _symbol_type_prefix_input_output = _symbols[offset + 8];
					final Opt type_prefix_input_output = (Opt) _symbol_type_prefix_input_output.value;
					final Symbol _symbol_class_access = _symbols[offset + 9];
					final Access class_access = (Access) _symbol_class_access.value;
					final Symbol _symbol_array_subscripts = _symbols[offset + 10];
					final Opt array_subscripts = (Opt) _symbol_array_subscripts.value;
					final Symbol _symbol_component_list = _symbols[offset + 11];
					final List component_list = (List) _symbol_component_list.value;
					final Symbol _symbol_constraining_clause = _symbols[offset + 12];
					final Opt constraining_clause = (Opt) _symbol_constraining_clause.value;
					final Symbol _symbol_comment = _symbols[offset + 13];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 14];
					 return new PN_ComponentClause(
            redeclare,
            final_,
            inner,
            outer,
            new Opt(replaceable),
            type_prefix_flow,
            type_prefix_variability,
            type_prefix_input_output,
            class_access,
            array_subscripts,
            component_list,
            constraining_clause,comment);
			}
			case 71: // element = error.error SEMICOLON.SEMICOLON
			{
					final Symbol error = _symbols[offset + 1];
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return new BadElement();
			}
			case 72: // constraining_clause = CONSTRAINEDBY.CONSTRAINEDBY class_access.class_access class_modification_opt.class_modification
			{
					final Symbol CONSTRAINEDBY = _symbols[offset + 1];
					final Symbol _symbol_class_access = _symbols[offset + 2];
					final Access class_access = (Access) _symbol_class_access.value;
					final Symbol _symbol_class_modification = _symbols[offset + 3];
					final Opt class_modification = (Opt) _symbol_class_modification.value;
					 return new ConstrainingClause(class_access,class_modification);
			}
			case 73: // extends_clause = EXTENDS.EXTENDS class_access.class_access class_modification_opt.class_modification annotation_opt.annotation
			{
					final Symbol EXTENDS = _symbols[offset + 1];
					final Symbol _symbol_class_access = _symbols[offset + 2];
					final Access class_access = (Access) _symbol_class_access.value;
					final Symbol _symbol_class_modification = _symbols[offset + 3];
					final Opt class_modification = (Opt) _symbol_class_modification.value;
					final Symbol _symbol_annotation = _symbols[offset + 4];
					final Opt annotation = (Opt) _symbol_annotation.value;
					 return new PN_ExtendsClause(class_access,class_modification,annotation);
			}
			case 74: // import_clause = IMPORT.IMPORT qualified_import_access.qualified_import_access comment.comment
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol _symbol_qualified_import_access = _symbols[offset + 2];
					final Access qualified_import_access = (Access) _symbol_qualified_import_access.value;
					final Symbol _symbol_comment = _symbols[offset + 3];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new ImportClauseQualified(qualified_import_access,comment);
			}
			case 75: // import_clause = IMPORT.IMPORT unqualified_import_access.unqualified_import_access comment.comment
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol _symbol_unqualified_import_access = _symbols[offset + 2];
					final Access unqualified_import_access = (Access) _symbol_unqualified_import_access.value;
					final Symbol _symbol_comment = _symbols[offset + 3];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new ImportClauseUnqualified(unqualified_import_access,comment);
			}
			case 76: // import_clause = IMPORT.IMPORT id_decl.alias EQUALS.EQUALS qualified_import_access.qualified_import_access comment.comment
			{
					final Symbol IMPORT = _symbols[offset + 1];
					final Symbol _symbol_alias = _symbols[offset + 2];
					final IdDecl alias = (IdDecl) _symbol_alias.value;
					final Symbol EQUALS = _symbols[offset + 3];
					final Symbol _symbol_qualified_import_access = _symbols[offset + 4];
					final Access qualified_import_access = (Access) _symbol_qualified_import_access.value;
					final Symbol _symbol_comment = _symbols[offset + 5];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new ImportClauseRename(qualified_import_access,comment,alias);
			}
			case 77: // array_subscripts = LBRACK.LBRACK subscript_list.subscript_list RBRACK.RBRACK
			{
					final Symbol LBRACK = _symbols[offset + 1];
					final Symbol _symbol_subscript_list = _symbols[offset + 2];
					final List subscript_list = (List) _symbol_subscript_list.value;
					final Symbol RBRACK = _symbols[offset + 3];
					 return new ArraySubscripts(subscript_list);
			}
			case 78: // subscript_list = subscript.subscript
			{
					final Symbol _symbol_subscript = _symbols[offset + 1];
					final Subscript subscript = (Subscript) _symbol_subscript.value;
					 return new List().add(subscript);
			}
			case 79: // subscript_list = subscript_list.subscript_list COMMA.COMMA subscript.subscript
			{
					final Symbol _symbol_subscript_list = _symbols[offset + 1];
					final List subscript_list = (List) _symbol_subscript_list.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_subscript = _symbols[offset + 3];
					final Subscript subscript = (Subscript) _symbol_subscript.value;
					 subscript_list.add(subscript);
                                      return subscript_list;
			}
			case 80: // subscript = COLON.COLON
			{
					final Symbol COLON = _symbols[offset + 1];
					 return new ColonSubscript();
			}
			case 81: // subscript = exp.exp
			{
					final Symbol _symbol_exp = _symbols[offset + 1];
					final Exp exp = (Exp) _symbol_exp.value;
					 return new ExpSubscript(exp);
			}
			case 82: // component_list = pn_component_decl.pn_component_decl
			{
					final Symbol _symbol_pn_component_decl = _symbols[offset + 1];
					final PN_ComponentDecl pn_component_decl = (PN_ComponentDecl) _symbol_pn_component_decl.value;
					 return new List().add(pn_component_decl);
			}
			case 83: // component_list = component_list.component_list COMMA.COMMA pn_component_decl.pn_component_decl
			{
					final Symbol _symbol_component_list = _symbols[offset + 1];
					final List component_list = (List) _symbol_component_list.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_pn_component_decl = _symbols[offset + 3];
					final PN_ComponentDecl pn_component_decl = (PN_ComponentDecl) _symbol_pn_component_decl.value;
					 component_list.add(pn_component_decl);
                                                      return component_list;
			}
			case 84: // pn_component_decl = id_decl.comp_name array_subscripts_opt.array_subscripts modification_opt.modification conditional_attribute_opt.conditional_attribute comment.comment
			{
					final Symbol _symbol_comp_name = _symbols[offset + 1];
					final IdDecl comp_name = (IdDecl) _symbol_comp_name.value;
					final Symbol _symbol_array_subscripts = _symbols[offset + 2];
					final Opt array_subscripts = (Opt) _symbol_array_subscripts.value;
					final Symbol _symbol_modification = _symbols[offset + 3];
					final Opt modification = (Opt) _symbol_modification.value;
					final Symbol _symbol_conditional_attribute = _symbols[offset + 4];
					final Opt conditional_attribute = (Opt) _symbol_conditional_attribute.value;
					final Symbol _symbol_comment = _symbols[offset + 5];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new PN_ComponentDecl(comp_name,array_subscripts,modification,conditional_attribute,comment);
			}
			case 85: // conditional_attribute = IF.IF exp.exp
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol _symbol_exp = _symbols[offset + 2];
					final Exp exp = (Exp) _symbol_exp.value;
					 return new ConditionalAttribute(exp);
			}
			case 86: // type_prefix_flow = FLOW.FLOW
			{
					final Symbol FLOW = _symbols[offset + 1];
					 return new Flow();
			}
			case 87: // type_prefix_flow = STREAM.STREAM
			{
					final Symbol STREAM = _symbols[offset + 1];
					 return new Stream();
			}
			case 88: // equation_clause = EQUATION.EQUATION abstract_equation_opt_list.abstract_equation
			{
					final Symbol EQUATION = _symbols[offset + 1];
					final Symbol _symbol_abstract_equation = _symbols[offset + 2];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					 return new EquationClause(abstract_equation);
			}
			case 89: // equation_clause = INITIAL_EQUATION.INITIAL_EQUATION abstract_equation_opt_list.abstract_equation
			{
					final Symbol INITIAL_EQUATION = _symbols[offset + 1];
					final Symbol _symbol_abstract_equation = _symbols[offset + 2];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					 //System.out.println("equation_clause"); 
  					     for (int i=0;i<abstract_equation.getNumChild();i++)
  					     	((AbstractEquation)abstract_equation.getChild(i)).setAbstractEquationModifier(new Initial()); 
  					     return new InitialEquationClause(abstract_equation);
			}
			case 90: // algorithm = ALGORITHM.ALGORITHM statement_list.statement_list
			{
					final Symbol ALGORITHM = _symbols[offset + 1];
					final Symbol _symbol_statement_list = _symbols[offset + 2];
					final List statement_list = (List) _symbol_statement_list.value;
					 return new Algorithm(new Opt(), statement_list);
			}
			case 91: // algorithm = INITIAL_ALGORITHM.INITIAL_ALGORITHM statement_list.statement_list
			{
					final Symbol INITIAL_ALGORITHM = _symbols[offset + 1];
					final Symbol _symbol_statement_list = _symbols[offset + 2];
					final List statement_list = (List) _symbol_statement_list.value;
					 return new Algorithm(new Opt(new Initial()), 
                                                              statement_list);
			}
			case 92: // statement_list = 
			{
					 return new List();
			}
			case 93: // statement_list = statement.statement
			{
					final Symbol _symbol_statement = _symbols[offset + 1];
					final Statement statement = (Statement) _symbol_statement.value;
					 return new List().add(statement);
			}
			case 94: // statement_list = statement_list.statement_list statement.statement
			{
					final Symbol _symbol_statement_list = _symbols[offset + 1];
					final List statement_list = (List) _symbol_statement_list.value;
					final Symbol _symbol_statement = _symbols[offset + 2];
					final Statement statement = (Statement) _symbol_statement.value;
					 statement_list.add(statement); 
                                 return statement_list;
			}
			case 95: // modification = complete_modification.complete_modification
			{
					final Symbol _symbol_complete_modification = _symbols[offset + 1];
					final CompleteModification complete_modification = (CompleteModification) _symbol_complete_modification.value;
					 return complete_modification;
			}
			case 96: // modification = value_modification.value_modification
			{
					final Symbol _symbol_value_modification = _symbols[offset + 1];
					final ValueModification value_modification = (ValueModification) _symbol_value_modification.value;
					 return value_modification;
			}
			case 97: // complete_modification = class_modification.class_modification value_modification_opt.value_modification
			{
					final Symbol _symbol_class_modification = _symbols[offset + 1];
					final ClassModification class_modification = (ClassModification) _symbol_class_modification.value;
					final Symbol _symbol_value_modification = _symbols[offset + 2];
					final Opt value_modification = (Opt) _symbol_value_modification.value;
					 return new CompleteModification(class_modification,value_modification);
			}
			case 98: // value_modification = EQUALS.EQUALS exp.exp
			{
					final Symbol EQUALS = _symbols[offset + 1];
					final Symbol _symbol_exp = _symbols[offset + 2];
					final Exp exp = (Exp) _symbol_exp.value;
					 return new ValueModification(exp);
			}
			case 99: // value_modification = COLON.COLON EQUALS.EQUALS exp.exp
			{
					final Symbol COLON = _symbols[offset + 1];
					final Symbol EQUALS = _symbols[offset + 2];
					final Symbol _symbol_exp = _symbols[offset + 3];
					final Exp exp = (Exp) _symbol_exp.value;
					 return new ValueModification(exp);
			}
			case 100: // class_modification = LPAREN.LPAREN RPAREN.RPAREN
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol RPAREN = _symbols[offset + 2];
					 return new ClassModification();
			}
			case 101: // class_modification = LPAREN.LPAREN argument_list.argument_list RPAREN.RPAREN
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_argument_list = _symbols[offset + 2];
					final List argument_list = (List) _symbol_argument_list.value;
					final Symbol RPAREN = _symbols[offset + 3];
					 return new ClassModification(argument_list);
			}
			case 102: // argument_list = argument.argument
			{
					final Symbol _symbol_argument = _symbols[offset + 1];
					final Argument argument = (Argument) _symbol_argument.value;
					 return new List().add(argument);
			}
			case 103: // argument_list = argument_list.argument_list COMMA.COMMA argument.argument
			{
					final Symbol _symbol_argument_list = _symbols[offset + 1];
					final List argument_list = (List) _symbol_argument_list.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_argument = _symbols[offset + 3];
					final Argument argument = (Argument) _symbol_argument.value;
					 argument_list.add(argument); 
                                       return argument_list;
			}
			case 104: // argument = each_opt.each final__opt.final_ parse_access.parse_access modification_opt.modification comment.comment
			{
					final Symbol _symbol_each = _symbols[offset + 1];
					final Opt each = (Opt) _symbol_each.value;
					final Symbol _symbol_final_ = _symbols[offset + 2];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_parse_access = _symbols[offset + 3];
					final Access parse_access = (Access) _symbol_parse_access.value;
					final Symbol _symbol_modification = _symbols[offset + 4];
					final Opt modification = (Opt) _symbol_modification.value;
					final Symbol _symbol_comment = _symbols[offset + 5];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new ComponentModification(each, 
                                                    final_,
                                                    parse_access,
                                                    modification,
                                                    comment);
			}
			case 105: // argument = each_opt.each final__opt.final_ replaceable.replaceable base_class_decl.base_class_decl constraining_clause_opt.constraining_clause
			{
					final Symbol _symbol_each = _symbols[offset + 1];
					final Opt each = (Opt) _symbol_each.value;
					final Symbol _symbol_final_ = _symbols[offset + 2];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_replaceable = _symbols[offset + 3];
					final Replaceable replaceable = (Replaceable) _symbol_replaceable.value;
					final Symbol _symbol_base_class_decl = _symbols[offset + 4];
					final BaseClassDecl base_class_decl = (BaseClassDecl) _symbol_base_class_decl.value;
					final Symbol _symbol_constraining_clause = _symbols[offset + 5];
					final Opt constraining_clause = (Opt) _symbol_constraining_clause.value;
					 ClassAccess pa = new ClassAccess(base_class_decl.getName().getID());
   							pa.setLocationNoTree(base_class_decl.getName());
   							base_class_decl.setConstrainingClauseOpt(constraining_clause);
   							base_class_decl.setReplaceable(replaceable);
   							ClassRedeclare cdr = new ClassRedeclare(each,
                                                         final_,
                                                         pa,
                                                         base_class_decl); 
                            return cdr;
			}
			case 106: // argument = each_opt.each final__opt.final_ replaceable.replaceable type_prefix_flow_opt.type_prefix_flow type_prefix_variability_opt.type_prefix_variability type_prefix_input_output_opt.type_prefix_input_output class_access.class_access id_decl.comp_name array_subscripts_opt.array_subscripts modification_opt.modification comment.comment constraining_clause_opt.constraining_clause
			{
					final Symbol _symbol_each = _symbols[offset + 1];
					final Opt each = (Opt) _symbol_each.value;
					final Symbol _symbol_final_ = _symbols[offset + 2];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_replaceable = _symbols[offset + 3];
					final Replaceable replaceable = (Replaceable) _symbol_replaceable.value;
					final Symbol _symbol_type_prefix_flow = _symbols[offset + 4];
					final Opt type_prefix_flow = (Opt) _symbol_type_prefix_flow.value;
					final Symbol _symbol_type_prefix_variability = _symbols[offset + 5];
					final Opt type_prefix_variability = (Opt) _symbol_type_prefix_variability.value;
					final Symbol _symbol_type_prefix_input_output = _symbols[offset + 6];
					final Opt type_prefix_input_output = (Opt) _symbol_type_prefix_input_output.value;
					final Symbol _symbol_class_access = _symbols[offset + 7];
					final Access class_access = (Access) _symbol_class_access.value;
					final Symbol _symbol_comp_name = _symbols[offset + 8];
					final IdDecl comp_name = (IdDecl) _symbol_comp_name.value;
					final Symbol _symbol_array_subscripts = _symbols[offset + 9];
					final Opt array_subscripts = (Opt) _symbol_array_subscripts.value;
					final Symbol _symbol_modification = _symbols[offset + 10];
					final Opt modification = (Opt) _symbol_modification.value;
					final Symbol _symbol_comment = _symbols[offset + 11];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol _symbol_constraining_clause = _symbols[offset + 12];
					final Opt constraining_clause = (Opt) _symbol_constraining_clause.value;
					 ParseAccess pa = new ParseAccess(comp_name.getID(),array_subscripts);
   				pa.setLocationNoTree(comp_name);
       			PN_ComponentDecl cd = new PN_ComponentDecl(comp_name,array_subscripts,modification,new Opt(),comment);
       			cd.setLocationNoTree(comp_name, comment);
   				PN_ComponentRedeclare cdr = new PN_ComponentRedeclare(each,
                                        final_,
                                        pa,
                                        new PN_ComponentClause(new Opt(new Redeclare()),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(new Replaceable()),
                                                               type_prefix_flow,
                                                               type_prefix_variability,
                                                               type_prefix_input_output,
                                                               class_access,
                                                               new Opt(),
                                                               new List().add(cd),
                                                               constraining_clause,
                                                               new Comment(new Opt(),new Opt()))); 
                                         return cdr;
			}
			case 107: // argument = REDECLARE.REDECLARE each_opt.each final__opt.final_ base_class_decl.base_class_decl
			{
					final Symbol REDECLARE = _symbols[offset + 1];
					final Symbol _symbol_each = _symbols[offset + 2];
					final Opt each = (Opt) _symbol_each.value;
					final Symbol _symbol_final_ = _symbols[offset + 3];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_base_class_decl = _symbols[offset + 4];
					final BaseClassDecl base_class_decl = (BaseClassDecl) _symbol_base_class_decl.value;
					 ClassAccess pa = new ClassAccess(base_class_decl.getName().getID());
                      pa.setLocationNoTree(base_class_decl.getName());       
                      base_class_decl.setRedeclare(new Redeclare());
                      ClassRedeclare cdr = new ClassRedeclare(each,
                                                              final_,
                                                              pa,
                                                              base_class_decl);
                      return cdr;
			}
			case 108: // argument = REDECLARE.REDECLARE each_opt.each final__opt.final_ type_prefix_flow_opt.type_prefix_flow type_prefix_variability_opt.type_prefix_variability type_prefix_input_output_opt.type_prefix_input_output class_access.class_access id_decl.comp_name array_subscripts_opt.array_subscripts modification_opt.modification comment.comment
			{
					final Symbol REDECLARE = _symbols[offset + 1];
					final Symbol _symbol_each = _symbols[offset + 2];
					final Opt each = (Opt) _symbol_each.value;
					final Symbol _symbol_final_ = _symbols[offset + 3];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_type_prefix_flow = _symbols[offset + 4];
					final Opt type_prefix_flow = (Opt) _symbol_type_prefix_flow.value;
					final Symbol _symbol_type_prefix_variability = _symbols[offset + 5];
					final Opt type_prefix_variability = (Opt) _symbol_type_prefix_variability.value;
					final Symbol _symbol_type_prefix_input_output = _symbols[offset + 6];
					final Opt type_prefix_input_output = (Opt) _symbol_type_prefix_input_output.value;
					final Symbol _symbol_class_access = _symbols[offset + 7];
					final Access class_access = (Access) _symbol_class_access.value;
					final Symbol _symbol_comp_name = _symbols[offset + 8];
					final IdDecl comp_name = (IdDecl) _symbol_comp_name.value;
					final Symbol _symbol_array_subscripts = _symbols[offset + 9];
					final Opt array_subscripts = (Opt) _symbol_array_subscripts.value;
					final Symbol _symbol_modification = _symbols[offset + 10];
					final Opt modification = (Opt) _symbol_modification.value;
					final Symbol _symbol_comment = _symbols[offset + 11];
					final Comment comment = (Comment) _symbol_comment.value;
					 ParseAccess pa = new ParseAccess(comp_name.getID(),array_subscripts);
   				pa.setLocationNoTree(comp_name, array_subscripts);
           		PN_ComponentDecl cd = new PN_ComponentDecl(comp_name,array_subscripts,modification,new Opt(),comment);
       			cd.setLocationNoTree(comp_name, comment);
   				PN_ComponentRedeclare cdr = new PN_ComponentRedeclare(each,
                                        final_,
                                        pa,
                                        new PN_ComponentClause(new Opt(new Redeclare()),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(),
                                                               type_prefix_flow,
                                                               type_prefix_variability,
                                                               type_prefix_input_output,
                                                               class_access,
                                                               new Opt(),
                                                               new List().add(cd),
                                                               new Opt(),
                                                               new Comment(new Opt(),new Opt()))); 
                 return cdr;
			}
			case 109: // argument = REDECLARE.REDECLARE each_opt.each final__opt.final_ replaceable.replaceable base_class_decl.base_class_decl constraining_clause_opt.constraining_clause
			{
					final Symbol REDECLARE = _symbols[offset + 1];
					final Symbol _symbol_each = _symbols[offset + 2];
					final Opt each = (Opt) _symbol_each.value;
					final Symbol _symbol_final_ = _symbols[offset + 3];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_replaceable = _symbols[offset + 4];
					final Replaceable replaceable = (Replaceable) _symbol_replaceable.value;
					final Symbol _symbol_base_class_decl = _symbols[offset + 5];
					final BaseClassDecl base_class_decl = (BaseClassDecl) _symbol_base_class_decl.value;
					final Symbol _symbol_constraining_clause = _symbols[offset + 6];
					final Opt constraining_clause = (Opt) _symbol_constraining_clause.value;
					 base_class_decl.setConstrainingClauseOpt(constraining_clause);
                            base_class_decl.setReplaceable(replaceable);
                            base_class_decl.setRedeclare(new Redeclare());
                            ClassAccess ca = new ClassAccess(base_class_decl.getName().getID());
                            ca.setLocationNoTree(base_class_decl.getName());
                             return new  ClassRedeclare(each,
                                                         final_,
                                                         ca,
                                                         base_class_decl);
			}
			case 110: // argument = REDECLARE.REDECLARE each_opt.each final__opt.final_ replaceable.replaceable type_prefix_flow_opt.type_prefix_flow type_prefix_variability_opt.type_prefix_variability type_prefix_input_output_opt.type_prefix_input_output class_access.class_access id_decl.comp_name array_subscripts_opt.array_subscripts modification_opt.modification comment.comment constraining_clause_opt.constraining_clause
			{
					final Symbol REDECLARE = _symbols[offset + 1];
					final Symbol _symbol_each = _symbols[offset + 2];
					final Opt each = (Opt) _symbol_each.value;
					final Symbol _symbol_final_ = _symbols[offset + 3];
					final Opt final_ = (Opt) _symbol_final_.value;
					final Symbol _symbol_replaceable = _symbols[offset + 4];
					final Replaceable replaceable = (Replaceable) _symbol_replaceable.value;
					final Symbol _symbol_type_prefix_flow = _symbols[offset + 5];
					final Opt type_prefix_flow = (Opt) _symbol_type_prefix_flow.value;
					final Symbol _symbol_type_prefix_variability = _symbols[offset + 6];
					final Opt type_prefix_variability = (Opt) _symbol_type_prefix_variability.value;
					final Symbol _symbol_type_prefix_input_output = _symbols[offset + 7];
					final Opt type_prefix_input_output = (Opt) _symbol_type_prefix_input_output.value;
					final Symbol _symbol_class_access = _symbols[offset + 8];
					final Access class_access = (Access) _symbol_class_access.value;
					final Symbol _symbol_comp_name = _symbols[offset + 9];
					final IdDecl comp_name = (IdDecl) _symbol_comp_name.value;
					final Symbol _symbol_array_subscripts = _symbols[offset + 10];
					final Opt array_subscripts = (Opt) _symbol_array_subscripts.value;
					final Symbol _symbol_modification = _symbols[offset + 11];
					final Opt modification = (Opt) _symbol_modification.value;
					final Symbol _symbol_comment = _symbols[offset + 12];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol _symbol_constraining_clause = _symbols[offset + 13];
					final Opt constraining_clause = (Opt) _symbol_constraining_clause.value;
					 ParseAccess pa = new ParseAccess(comp_name.getID(),array_subscripts);
       pa.setLocationNoTree(comp_name);
       PN_ComponentDecl cd = new PN_ComponentDecl(comp_name,array_subscripts,modification,new Opt(),comment);
       cd.setLocationNoTree(comp_name, comment);
       PN_ComponentRedeclare cr = new PN_ComponentRedeclare(each,
                                        final_,
                                        pa,
                                        new PN_ComponentClause(new Opt(new Redeclare()),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(),
                                                               new Opt(new Replaceable()),
                                                               type_prefix_flow,
                                                               type_prefix_variability,
                                                               type_prefix_input_output,
                                                               class_access,
                                                               new Opt(),
                                                               new List().add(cd),
                                                               constraining_clause,
                                                               new Comment(new Opt(),new Opt()))); 
        return cr;
			}
			case 111: // argument = error.error
			{
					final Symbol error = _symbols[offset + 1];
					 return new BadArgument();
			}
			case 112: // annotation = annotation_tok.annotation_tok class_modification.class_modification
			{
					final Symbol _symbol_annotation_tok = _symbols[offset + 1];
					final Symbol annotation_tok = (Symbol) _symbol_annotation_tok.value;
					final Symbol _symbol_class_modification = _symbols[offset + 2];
					final ClassModification class_modification = (ClassModification) _symbol_class_modification.value;
					 annotationTok = null; return new ParseAnnotation(class_modification);
			}
			case 113: // annotation_tok = ANNOTATION.ANNOTATION
			{
					final Symbol ANNOTATION = _symbols[offset + 1];
					 if (annotationTok != null) {
        getReport().syntaxError(ANNOTATION);
    }
    annotationTok = ANNOTATION;
    return new Symbol(ANNOTATION);
			}
			case 114: // abstract_equation = exp.left EQUALS.EQUALS exp.right comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_left = _symbols[offset + 1];
					final Exp left = (Exp) _symbol_left.value;
					final Symbol EQUALS = _symbols[offset + 2];
					final Symbol _symbol_right = _symbols[offset + 3];
					final Exp right = (Exp) _symbol_right.value;
					final Symbol _symbol_comment = _symbols[offset + 4];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 5];
					 return new Equation(new Opt(),comment,left,right);
			}
			case 115: // abstract_equation = if_equation.if_equation SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_if_equation = _symbols[offset + 1];
					final IfEquation if_equation = (IfEquation) _symbol_if_equation.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return if_equation;
			}
			case 116: // abstract_equation = for_clause_e.for_clause_e SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_for_clause_e = _symbols[offset + 1];
					final ForClauseE for_clause_e = (ForClauseE) _symbol_for_clause_e.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return for_clause_e;
			}
			case 117: // abstract_equation = when_equation.when_equation SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_when_equation = _symbols[offset + 1];
					final WhenEquation when_equation = (WhenEquation) _symbol_when_equation.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return when_equation;
			}
			case 118: // abstract_equation = CONNECT.CONNECT LPAREN.LPAREN parse_access.a COMMA.COMMA parse_access.b RPAREN.RPAREN comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol CONNECT = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_a = _symbols[offset + 3];
					final Access a = (Access) _symbol_a.value;
					final Symbol COMMA = _symbols[offset + 4];
					final Symbol _symbol_b = _symbols[offset + 5];
					final Access b = (Access) _symbol_b.value;
					final Symbol RPAREN = _symbols[offset + 6];
					final Symbol _symbol_comment = _symbols[offset + 7];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 8];
					 return new ConnectClause(new Opt(), comment,a,b);
			}
			case 119: // abstract_equation = LPAREN.LPAREN function_call_left_list.function_call_left_list RPAREN.RPAREN EQUALS.EQUALS function_call.function_call comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_function_call_left_list = _symbols[offset + 2];
					final List function_call_left_list = (List) _symbol_function_call_left_list.value;
					final Symbol RPAREN = _symbols[offset + 3];
					final Symbol EQUALS = _symbols[offset + 4];
					final Symbol _symbol_function_call = _symbols[offset + 5];
					final FunctionCall function_call = (FunctionCall) _symbol_function_call.value;
					final Symbol _symbol_comment = _symbols[offset + 6];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 7];
					 return new FunctionCallEquation(new Opt(),comment,function_call_left_list,function_call);
			}
			case 120: // abstract_equation = function_call.function_call comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_function_call = _symbols[offset + 1];
					final FunctionCall function_call = (FunctionCall) _symbol_function_call.value;
					final Symbol _symbol_comment = _symbols[offset + 2];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new FunctionCallEquation(new Opt(),comment,new List(),function_call);
			}
			case 121: // function_call_left_list = function_call_left.a COMMA.COMMA function_call_left.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final FunctionCallLeft a = (FunctionCallLeft) _symbol_a.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final FunctionCallLeft b = (FunctionCallLeft) _symbol_b.value;
					 return new List().add(a).add(b);
			}
			case 122: // function_call_left_list = function_call_left_list.function_call_left_list COMMA.COMMA function_call_left.function_call_left
			{
					final Symbol _symbol_function_call_left_list = _symbols[offset + 1];
					final List function_call_left_list = (List) _symbol_function_call_left_list.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_function_call_left = _symbols[offset + 3];
					final FunctionCallLeft function_call_left = (FunctionCallLeft) _symbol_function_call_left.value;
					 return function_call_left_list.add(function_call_left);
			}
			case 123: // function_call_left = 
			{
					 return new FunctionCallLeft(new Opt());
			}
			case 124: // function_call_left = parse_access.parse_access
			{
					final Symbol _symbol_parse_access = _symbols[offset + 1];
					final Access parse_access = (Access) _symbol_parse_access.value;
					 return new FunctionCallLeft(new Opt(parse_access));
			}
			case 125: // for_clause_e = FOR.FOR for_indices.for_indices LOOP.LOOP abstract_equation_opt_list.abstract_equation END_FOR.END_FOR comment.comment
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol _symbol_for_indices = _symbols[offset + 2];
					final List for_indices = (List) _symbol_for_indices.value;
					final Symbol LOOP = _symbols[offset + 3];
					final Symbol _symbol_abstract_equation = _symbols[offset + 4];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					final Symbol END_FOR = _symbols[offset + 5];
					final Symbol _symbol_comment = _symbols[offset + 6];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new ForClauseE(new Opt(), comment, for_indices,abstract_equation);
			}
			case 126: // for_indices = for_index.for_index
			{
					final Symbol _symbol_for_index = _symbols[offset + 1];
					final ForIndex for_index = (ForIndex) _symbol_for_index.value;
					 return new List().add(for_index);
			}
			case 127: // for_indices = for_indices.for_indices COMMA.COMMA for_index.for_index
			{
					final Symbol _symbol_for_indices = _symbols[offset + 1];
					final List for_indices = (List) _symbol_for_indices.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_for_index = _symbols[offset + 3];
					final ForIndex for_index = (ForIndex) _symbol_for_index.value;
					 for_indices.add(for_index);
                                     return for_indices;
			}
			case 128: // for_index = id_decl.id_decl for_in_exp_opt.for_in_exp
			{
					final Symbol _symbol_id_decl = _symbols[offset + 1];
					final IdDecl id_decl = (IdDecl) _symbol_id_decl.value;
					final Symbol _symbol_for_in_exp = _symbols[offset + 2];
					final Opt for_in_exp = (Opt) _symbol_for_in_exp.value;
					 ForIndex f = new ForIndex(new ForIndexDecl(new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(new IndexParameter()),
                                                              new Opt(),
                                                              new ParseAccess("Integer",new Opt()),
                                                              new Opt(),
                                                              new PublicVisibilityType(),
                                                              id_decl,
                                                              new Opt(),
                                                              new Opt(),
                                                              new Opt(),
                                                              new Comment(new Opt(),new Opt()),
                                                              new Opt(),
                                                              new Comment(new Opt(),new Opt())),
                                                   for_in_exp); 
                          f.setLocationNoTree(id_decl, for_in_exp); 
                          return f;
			}
			case 129: // for_in_exp = IN.IN exp.e
			{
					final Symbol IN = _symbols[offset + 1];
					final Symbol _symbol_e = _symbols[offset + 2];
					final Exp e = (Exp) _symbol_e.value;
					 return e;
			}
			case 130: // when_equation = WHEN.WHEN exp.test THEN.THEN abstract_equation_opt_list.abstract_equation else_when_equation_opt.else_when_equation END_WHEN.END_WHEN comment.comment
			{
					final Symbol WHEN = _symbols[offset + 1];
					final Symbol _symbol_test = _symbols[offset + 2];
					final Exp test = (Exp) _symbol_test.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_abstract_equation = _symbols[offset + 4];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					final Symbol _symbol_else_when_equation = _symbols[offset + 5];
					final Opt else_when_equation = (Opt) _symbol_else_when_equation.value;
					final Symbol END_WHEN = _symbols[offset + 6];
					final Symbol _symbol_comment = _symbols[offset + 7];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new WhenEquation(new Opt(), 
                                                  comment, 
                                                  abstract_equation,
                                                  test, 
                                                  else_when_equation);
			}
			case 131: // else_when_equation = ELSEWHEN.ELSEWHEN exp.test THEN.THEN abstract_equation_opt_list.abstract_equation else_when_equation_opt.else_when_equation
			{
					final Symbol ELSEWHEN = _symbols[offset + 1];
					final Symbol _symbol_test = _symbols[offset + 2];
					final Exp test = (Exp) _symbol_test.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_abstract_equation = _symbols[offset + 4];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					final Symbol _symbol_else_when_equation = _symbols[offset + 5];
					final Opt else_when_equation = (Opt) _symbol_else_when_equation.value;
					 return new WhenEquation(new Opt(), 
                                                     new Comment(), 
                                                     abstract_equation, 
                                                     test, 
                                                     else_when_equation);
			}
			case 132: // if_equation = IF.IF exp.test THEN.THEN abstract_equation_opt_list.abstract_equation else_if_equation_opt.else_if_equation END_IF.END_IF comment.comment
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol _symbol_test = _symbols[offset + 2];
					final Exp test = (Exp) _symbol_test.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_abstract_equation = _symbols[offset + 4];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					final Symbol _symbol_else_if_equation = _symbols[offset + 5];
					final Opt else_if_equation = (Opt) _symbol_else_if_equation.value;
					final Symbol END_IF = _symbols[offset + 6];
					final Symbol _symbol_comment = _symbols[offset + 7];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new IfEquation(new Opt(), 
                                               comment, 
                                               abstract_equation, 
                                               test, 
                                               else_if_equation);
			}
			case 133: // else_if_equation = ELSEIF.ELSEIF exp.test THEN.THEN abstract_equation_opt_list.abstract_equation else_if_equation_opt.else_if_equation
			{
					final Symbol ELSEIF = _symbols[offset + 1];
					final Symbol _symbol_test = _symbols[offset + 2];
					final Exp test = (Exp) _symbol_test.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_abstract_equation = _symbols[offset + 4];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					final Symbol _symbol_else_if_equation = _symbols[offset + 5];
					final Opt else_if_equation = (Opt) _symbol_else_if_equation.value;
					 return new IfEquation(new Opt(), 
                                                      new Comment(), 
                                                      abstract_equation, 
                                                      test, 
                                                      else_if_equation);
			}
			case 134: // else_if_equation = ELSE.ELSE abstract_equation_opt_list.abstract_equation
			{
					final Symbol ELSE = _symbols[offset + 1];
					final Symbol _symbol_abstract_equation = _symbols[offset + 2];
					final List abstract_equation = (List) _symbol_abstract_equation.value;
					 return new ElseEquation(new Opt(), 
                                                        new Comment(), 
                                                        abstract_equation);
			}
			case 135: // statement = parse_access.left ASSIGN.ASSIGN exp.right comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_left = _symbols[offset + 1];
					final Access left = (Access) _symbol_left.value;
					final Symbol ASSIGN = _symbols[offset + 2];
					final Symbol _symbol_right = _symbols[offset + 3];
					final Exp right = (Exp) _symbol_right.value;
					final Symbol _symbol_comment = _symbols[offset + 4];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 5];
					 return new AssignStmt(comment, left, right);
			}
			case 136: // statement = function_call_stmt.function_call_stmt SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_function_call_stmt = _symbols[offset + 1];
					final FunctionCallStmt function_call_stmt = (FunctionCallStmt) _symbol_function_call_stmt.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return function_call_stmt;
			}
			case 137: // statement = BREAK.BREAK comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol BREAK = _symbols[offset + 1];
					final Symbol _symbol_comment = _symbols[offset + 2];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new BreakStmt(comment);
			}
			case 138: // statement = RETURN.RETURN comment.comment SEMICOLON.SEMICOLON
			{
					final Symbol RETURN = _symbols[offset + 1];
					final Symbol _symbol_comment = _symbols[offset + 2];
					final Comment comment = (Comment) _symbol_comment.value;
					final Symbol SEMICOLON = _symbols[offset + 3];
					 return new ReturnStmt(comment);
			}
			case 139: // statement = if_stmt.if_stmt SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_if_stmt = _symbols[offset + 1];
					final IfStmt if_stmt = (IfStmt) _symbol_if_stmt.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return if_stmt;
			}
			case 140: // statement = when_stmt.when_stmt SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_when_stmt = _symbols[offset + 1];
					final WhenStmt when_stmt = (WhenStmt) _symbol_when_stmt.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return when_stmt;
			}
			case 141: // statement = for_stmt.for_stmt SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_for_stmt = _symbols[offset + 1];
					final ForStmt for_stmt = (ForStmt) _symbol_for_stmt.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return for_stmt;
			}
			case 142: // statement = while_stmt.while_stmt SEMICOLON.SEMICOLON
			{
					final Symbol _symbol_while_stmt = _symbols[offset + 1];
					final WhileStmt while_stmt = (WhileStmt) _symbol_while_stmt.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					 return while_stmt;
			}
			case 143: // statement = error.error
			{
					final Symbol error = _symbols[offset + 1];
					 return new BadStatement();
			}
			case 144: // function_call_stmt = LPAREN.LPAREN function_call_stmt_left_list.function_call_stmt_left_list RPAREN.RPAREN ASSIGN.ASSIGN function_call.function_call comment.comment
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_function_call_stmt_left_list = _symbols[offset + 2];
					final List function_call_stmt_left_list = (List) _symbol_function_call_stmt_left_list.value;
					final Symbol RPAREN = _symbols[offset + 3];
					final Symbol ASSIGN = _symbols[offset + 4];
					final Symbol _symbol_function_call = _symbols[offset + 5];
					final FunctionCall function_call = (FunctionCall) _symbol_function_call.value;
					final Symbol _symbol_comment = _symbols[offset + 6];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new FunctionCallStmt(comment, function_call_stmt_left_list, function_call);
			}
			case 145: // function_call_stmt = function_call.function_call comment.comment
			{
					final Symbol _symbol_function_call = _symbols[offset + 1];
					final FunctionCall function_call = (FunctionCall) _symbol_function_call.value;
					final Symbol _symbol_comment = _symbols[offset + 2];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new FunctionCallStmt(comment, new List(), function_call);
			}
			case 146: // function_call_stmt_left_list = function_call_stmt_left.function_call_stmt_left
			{
					final Symbol _symbol_function_call_stmt_left = _symbols[offset + 1];
					final FunctionCallLeft function_call_stmt_left = (FunctionCallLeft) _symbol_function_call_stmt_left.value;
					 return new List().add(function_call_stmt_left);
			}
			case 147: // function_call_stmt_left_list = function_call_stmt_left_list.function_call_stmt_left_list COMMA.COMMA function_call_stmt_left.function_call_stmt_left
			{
					final Symbol _symbol_function_call_stmt_left_list = _symbols[offset + 1];
					final List function_call_stmt_left_list = (List) _symbol_function_call_stmt_left_list.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_function_call_stmt_left = _symbols[offset + 3];
					final FunctionCallLeft function_call_stmt_left = (FunctionCallLeft) _symbol_function_call_stmt_left.value;
					 return function_call_stmt_left_list.add(function_call_stmt_left);
			}
			case 148: // function_call_stmt_left = 
			{
					 return new FunctionCallLeft(new Opt());
			}
			case 149: // function_call_stmt_left = parse_access.parse_access
			{
					final Symbol _symbol_parse_access = _symbols[offset + 1];
					final Access parse_access = (Access) _symbol_parse_access.value;
					 return new FunctionCallLeft(new Opt(parse_access));
			}
			case 150: // if_stmt = IF.IF if_clause_list.if_clause_list else_stmts.else_stmts END_IF.END_IF comment.comment
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol _symbol_if_clause_list = _symbols[offset + 2];
					final List if_clause_list = (List) _symbol_if_clause_list.value;
					final Symbol _symbol_else_stmts = _symbols[offset + 3];
					final ElseClause else_stmts = (ElseClause) _symbol_else_stmts.value;
					final Symbol END_IF = _symbols[offset + 4];
					final Symbol _symbol_comment = _symbols[offset + 5];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new IfStmt(comment, if_clause_list, new Opt(else_stmts));
			}
			case 151: // if_stmt = IF.IF if_clause_list.if_clause_list END_IF.END_IF comment.comment
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol _symbol_if_clause_list = _symbols[offset + 2];
					final List if_clause_list = (List) _symbol_if_clause_list.value;
					final Symbol END_IF = _symbols[offset + 3];
					final Symbol _symbol_comment = _symbols[offset + 4];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new IfStmt(comment, if_clause_list, new Opt());
			}
			case 152: // if_clause_list = if_clause.if_clause
			{
					final Symbol _symbol_if_clause = _symbols[offset + 1];
					final IfClause if_clause = (IfClause) _symbol_if_clause.value;
					 return new List().add(if_clause);
			}
			case 153: // if_clause_list = if_clause_list.if_clause_list ELSEIF.ELSEIF if_clause.if_clause
			{
					final Symbol _symbol_if_clause_list = _symbols[offset + 1];
					final List if_clause_list = (List) _symbol_if_clause_list.value;
					final Symbol ELSEIF = _symbols[offset + 2];
					final Symbol _symbol_if_clause = _symbols[offset + 3];
					final IfClause if_clause = (IfClause) _symbol_if_clause.value;
					 return if_clause_list.add(if_clause);
			}
			case 154: // if_clause = exp.exp THEN.THEN statement_list.statement_list
			{
					final Symbol _symbol_exp = _symbols[offset + 1];
					final Exp exp = (Exp) _symbol_exp.value;
					final Symbol THEN = _symbols[offset + 2];
					final Symbol _symbol_statement_list = _symbols[offset + 3];
					final List statement_list = (List) _symbol_statement_list.value;
					 return new IfClause(exp, statement_list);
			}
			case 155: // else_stmts = ELSE.ELSE statement_list.statement_list
			{
					final Symbol ELSE = _symbols[offset + 1];
					final Symbol _symbol_statement_list = _symbols[offset + 2];
					final List statement_list = (List) _symbol_statement_list.value;
					 return new ElseClause(statement_list);
			}
			case 156: // when_stmt = WHEN.WHEN when_clause_list.when_clause_list END_WHEN.END_WHEN comment.comment
			{
					final Symbol WHEN = _symbols[offset + 1];
					final Symbol _symbol_when_clause_list = _symbols[offset + 2];
					final List when_clause_list = (List) _symbol_when_clause_list.value;
					final Symbol END_WHEN = _symbols[offset + 3];
					final Symbol _symbol_comment = _symbols[offset + 4];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new WhenStmt(comment, when_clause_list);
			}
			case 157: // when_clause_list = when_clause.when_clause
			{
					final Symbol _symbol_when_clause = _symbols[offset + 1];
					final WhenClause when_clause = (WhenClause) _symbol_when_clause.value;
					 return new List().add(when_clause);
			}
			case 158: // when_clause_list = when_clause_list.when_clause_list ELSEWHEN.ELSEWHEN when_clause.when_clause
			{
					final Symbol _symbol_when_clause_list = _symbols[offset + 1];
					final List when_clause_list = (List) _symbol_when_clause_list.value;
					final Symbol ELSEWHEN = _symbols[offset + 2];
					final Symbol _symbol_when_clause = _symbols[offset + 3];
					final WhenClause when_clause = (WhenClause) _symbol_when_clause.value;
					 return when_clause_list.add(when_clause);
			}
			case 159: // when_clause = exp.exp THEN.THEN statement_list.statement_list
			{
					final Symbol _symbol_exp = _symbols[offset + 1];
					final Exp exp = (Exp) _symbol_exp.value;
					final Symbol THEN = _symbols[offset + 2];
					final Symbol _symbol_statement_list = _symbols[offset + 3];
					final List statement_list = (List) _symbol_statement_list.value;
					 return new WhenClause(exp, statement_list);
			}
			case 160: // for_stmt = FOR.FOR for_indices.for_indices LOOP.LOOP for_stmt_list.for_stmt_list END_FOR.END_FOR comment.comment
			{
					final Symbol FOR = _symbols[offset + 1];
					final Symbol _symbol_for_indices = _symbols[offset + 2];
					final List for_indices = (List) _symbol_for_indices.value;
					final Symbol LOOP = _symbols[offset + 3];
					final Symbol _symbol_for_stmt_list = _symbols[offset + 4];
					final ForStmtList for_stmt_list = (ForStmtList) _symbol_for_stmt_list.value;
					final Symbol END_FOR = _symbols[offset + 5];
					final Symbol _symbol_comment = _symbols[offset + 6];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new ForStmt(comment, for_indices, for_stmt_list);
			}
			case 161: // for_stmt_list = statement_list.statement_list
			{
					final Symbol _symbol_statement_list = _symbols[offset + 1];
					final List statement_list = (List) _symbol_statement_list.value;
					 return new ForStmtList(statement_list);
			}
			case 162: // while_stmt = WHILE.WHILE exp.exp LOOP.LOOP statement_list.statement_list END_WHILE.END_WHILE comment.comment
			{
					final Symbol WHILE = _symbols[offset + 1];
					final Symbol _symbol_exp = _symbols[offset + 2];
					final Exp exp = (Exp) _symbol_exp.value;
					final Symbol LOOP = _symbols[offset + 3];
					final Symbol _symbol_statement_list = _symbols[offset + 4];
					final List statement_list = (List) _symbol_statement_list.value;
					final Symbol END_WHILE = _symbols[offset + 5];
					final Symbol _symbol_comment = _symbols[offset + 6];
					final Comment comment = (Comment) _symbol_comment.value;
					 return new WhileStmt(comment, exp, statement_list);
			}
			case 163: // exp = simple_expression.simple_expression
			{
					final Symbol _symbol_simple_expression = _symbols[offset + 1];
					final Exp simple_expression = (Exp) _symbol_simple_expression.value;
					 return simple_expression;
			}
			case 164: // exp = if_exp.if_exp
			{
					final Symbol _symbol_if_exp = _symbols[offset + 1];
					final IfExp if_exp = (IfExp) _symbol_if_exp.value;
					 return if_exp;
			}
			case 165: // if_exp = IF.IF exp.ifexp THEN.THEN exp.thenexp else_if_exp.else_if_exp
			{
					final Symbol IF = _symbols[offset + 1];
					final Symbol _symbol_ifexp = _symbols[offset + 2];
					final Exp ifexp = (Exp) _symbol_ifexp.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_thenexp = _symbols[offset + 4];
					final Exp thenexp = (Exp) _symbol_thenexp.value;
					final Symbol _symbol_else_if_exp = _symbols[offset + 5];
					final Exp else_if_exp = (Exp) _symbol_else_if_exp.value;
					 return new IfExp(ifexp, thenexp, else_if_exp);
			}
			case 166: // else_if_exp = ELSEIF.ELSEIF exp.ifexp THEN.THEN exp.thenexp else_if_exp.else_if_exp
			{
					final Symbol ELSEIF = _symbols[offset + 1];
					final Symbol _symbol_ifexp = _symbols[offset + 2];
					final Exp ifexp = (Exp) _symbol_ifexp.value;
					final Symbol THEN = _symbols[offset + 3];
					final Symbol _symbol_thenexp = _symbols[offset + 4];
					final Exp thenexp = (Exp) _symbol_thenexp.value;
					final Symbol _symbol_else_if_exp = _symbols[offset + 5];
					final Exp else_if_exp = (Exp) _symbol_else_if_exp.value;
					 return new IfExp(ifexp, thenexp, else_if_exp);
			}
			case 167: // else_if_exp = ELSE.ELSE exp.exp
			{
					final Symbol ELSE = _symbols[offset + 1];
					final Symbol _symbol_exp = _symbols[offset + 2];
					final Exp exp = (Exp) _symbol_exp.value;
					 return exp;
			}
			case 168: // simple_expression = log_exp.log_exp
			{
					final Symbol _symbol_log_exp = _symbols[offset + 1];
					final Exp log_exp = (Exp) _symbol_log_exp.value;
					 return log_exp;
			}
			case 169: // simple_expression = log_exp.l1 COLON.COLON log_exp.l2
			{
					final Symbol _symbol_l1 = _symbols[offset + 1];
					final Exp l1 = (Exp) _symbol_l1.value;
					final Symbol COLON = _symbols[offset + 2];
					final Symbol _symbol_l2 = _symbols[offset + 3];
					final Exp l2 = (Exp) _symbol_l2.value;
					 RangeExp r = new RangeExp();
           r.addExp(l1);
           r.addExp(l2);
           return r;
			}
			case 170: // simple_expression = log_exp.l1 COLON.COLON log_exp.l2 COLON.COLON_ log_exp.l3
			{
					final Symbol _symbol_l1 = _symbols[offset + 1];
					final Exp l1 = (Exp) _symbol_l1.value;
					final Symbol COLON = _symbols[offset + 2];
					final Symbol _symbol_l2 = _symbols[offset + 3];
					final Exp l2 = (Exp) _symbol_l2.value;
					final Symbol COLON_ = _symbols[offset + 4];
					final Symbol _symbol_l3 = _symbols[offset + 5];
					final Exp l3 = (Exp) _symbol_l3.value;
					 RangeExp r = new RangeExp();
           r.addExp(l1);
           r.addExp(l2);
           r.addExp(l3);
           return r;
			}
			case 171: // log_exp = log_exp.a OR.OR log_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol OR = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new OrExp(a,b);
			}
			case 172: // log_exp = log_exp.a AND.AND log_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol AND = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new AndExp(a,b);
			}
			case 173: // log_exp = NOT.NOT relation.a
			{
					final Symbol NOT = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Exp a = (Exp) _symbol_a.value;
					 return new NotExp(a);
			}
			case 174: // log_exp = relation.relation
			{
					final Symbol _symbol_relation = _symbols[offset + 1];
					final Exp relation = (Exp) _symbol_relation.value;
					 return relation;
			}
			case 175: // relation = artm_exp.a LT.LT artm_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol LT = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new LtExp(a,b);
			}
			case 176: // relation = artm_exp.a LEQ.LEQ artm_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol LEQ = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new LeqExp(a,b);
			}
			case 177: // relation = artm_exp.a GT.GT artm_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol GT = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new GtExp(a,b);
			}
			case 178: // relation = artm_exp.a GEQ.GEQ artm_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol GEQ = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new GeqExp(a,b);
			}
			case 179: // relation = artm_exp.a EQ.EQ artm_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol EQ = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new EqExp(a,b);
			}
			case 180: // relation = artm_exp.a NEQ.NEQ artm_exp.b
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol NEQ = _symbols[offset + 2];
					final Symbol _symbol_b = _symbols[offset + 3];
					final Exp b = (Exp) _symbol_b.value;
					 return new NeqExp(a,b);
			}
			case 181: // relation = artm_exp.a
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					 return a;
			}
			case 182: // artm_exp = additive_exp.additive_exp
			{
					final Symbol _symbol_additive_exp = _symbols[offset + 1];
					final Exp additive_exp = (Exp) _symbol_additive_exp.value;
					 return additive_exp;
			}
			case 183: // additive_exp = multiplicative_exp.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Exp e = (Exp) _symbol_e.value;
					 return e;
			}
			case 184: // additive_exp = additive_exp.e1 PLUS.PLUS multiplicative_exp.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Exp e1 = (Exp) _symbol_e1.value;
					final Symbol PLUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Exp e2 = (Exp) _symbol_e2.value;
					 return new AddExp(e1, e2);
			}
			case 185: // additive_exp = additive_exp.e1 MINUS.MINUS multiplicative_exp.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Exp e1 = (Exp) _symbol_e1.value;
					final Symbol MINUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Exp e2 = (Exp) _symbol_e2.value;
					 return new SubExp(e1, e2);
			}
			case 186: // additive_exp = additive_exp.e1 DOTPLUS.DOTPLUS multiplicative_exp.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Exp e1 = (Exp) _symbol_e1.value;
					final Symbol DOTPLUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Exp e2 = (Exp) _symbol_e2.value;
					 return new DotAddExp(e1, e2);
			}
			case 187: // additive_exp = additive_exp.e1 DOTMINUS.DOTMINUS multiplicative_exp.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Exp e1 = (Exp) _symbol_e1.value;
					final Symbol DOTMINUS = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Exp e2 = (Exp) _symbol_e2.value;
					 return new DotSubExp(e1, e2);
			}
			case 188: // multiplicative_exp = unary_exp.e
			{
					final Symbol _symbol_e = _symbols[offset + 1];
					final Exp e = (Exp) _symbol_e.value;
					 return e;
			}
			case 189: // multiplicative_exp = multiplicative_exp.e1 MULT.MULT unary_exp.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Exp e1 = (Exp) _symbol_e1.value;
					final Symbol MULT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Exp e2 = (Exp) _symbol_e2.value;
					 return new MulExp(e1, e2);
			}
			case 190: // multiplicative_exp = multiplicative_exp.e1 DIV.DIV unary_exp.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Exp e1 = (Exp) _symbol_e1.value;
					final Symbol DIV = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Exp e2 = (Exp) _symbol_e2.value;
					 return new DivExp(e1, e2);
			}
			case 191: // multiplicative_exp = multiplicative_exp.e1 DOTMULT.DOTMULT unary_exp.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Exp e1 = (Exp) _symbol_e1.value;
					final Symbol DOTMULT = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Exp e2 = (Exp) _symbol_e2.value;
					 return new DotMulExp(e1, e2);
			}
			case 192: // multiplicative_exp = multiplicative_exp.e1 DOTDIV.DOTDIV unary_exp.e2
			{
					final Symbol _symbol_e1 = _symbols[offset + 1];
					final Exp e1 = (Exp) _symbol_e1.value;
					final Symbol DOTDIV = _symbols[offset + 2];
					final Symbol _symbol_e2 = _symbols[offset + 3];
					final Exp e2 = (Exp) _symbol_e2.value;
					 return new DotDivExp(e1, e2);
			}
			case 193: // unary_exp = pow_exp.pow_exp
			{
					final Symbol _symbol_pow_exp = _symbols[offset + 1];
					final Exp pow_exp = (Exp) _symbol_pow_exp.value;
					 return pow_exp;
			}
			case 194: // unary_exp = MINUS.MINUS unary_exp.unary_exp
			{
					final Symbol MINUS = _symbols[offset + 1];
					final Symbol _symbol_unary_exp = _symbols[offset + 2];
					final Exp unary_exp = (Exp) _symbol_unary_exp.value;
					 return new NegExp(unary_exp);
			}
			case 195: // unary_exp = PLUS.PLUS unary_exp.unary_exp
			{
					final Symbol PLUS = _symbols[offset + 1];
					final Symbol _symbol_unary_exp = _symbols[offset + 2];
					final Exp unary_exp = (Exp) _symbol_unary_exp.value;
					 return unary_exp;
			}
			case 196: // pow_exp = primary.primary
			{
					final Symbol _symbol_primary = _symbols[offset + 1];
					final Exp primary = (Exp) _symbol_primary.value;
					 return primary;
			}
			case 197: // pow_exp = primary.a POW.POW primary.e
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol POW = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Exp e = (Exp) _symbol_e.value;
					 return new PowExp(a,e);
			}
			case 198: // pow_exp = primary.a DOTPOW.DOTPOW primary.e
			{
					final Symbol _symbol_a = _symbols[offset + 1];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol DOTPOW = _symbols[offset + 2];
					final Symbol _symbol_e = _symbols[offset + 3];
					final Exp e = (Exp) _symbol_e.value;
					 return new DotPowExp(a,e);
			}
			case 199: // primary = UNSIGNED_NUMBER.n
			{
					final Symbol n = _symbols[offset + 1];
					 return new RealLitExp(((String)n.value));
			}
			case 200: // primary = UNSIGNED_INTEGER.n
			{
					final Symbol n = _symbols[offset + 1];
					 return new IntegerLitExp(((String)n.value));
			}
			case 201: // primary = TRUE.TRUE
			{
					final Symbol TRUE = _symbols[offset + 1];
					 return new BooleanLitExpTrue();
			}
			case 202: // primary = FALSE.FALSE
			{
					final Symbol FALSE = _symbols[offset + 1];
					 return new BooleanLitExpFalse();
			}
			case 203: // primary = STRING.s
			{
					final Symbol s = _symbols[offset + 1];
					 return new StringLitExp(((String)s.value));
			}
			case 204: // primary = access_expression.access_expression
			{
					final Symbol _symbol_access_expression = _symbols[offset + 1];
					final AccessExp access_expression = (AccessExp) _symbol_access_expression.value;
					 return access_expression;
			}
			case 205: // primary = der_expression.der_expression
			{
					final Symbol _symbol_der_expression = _symbols[offset + 1];
					final DerExp der_expression = (DerExp) _symbol_der_expression.value;
					 return der_expression;
			}
			case 206: // primary = LPAREN.LPAREN exp.a RPAREN.RPAREN
			{
					final Symbol LPAREN = _symbols[offset + 1];
					final Symbol _symbol_a = _symbols[offset + 2];
					final Exp a = (Exp) _symbol_a.value;
					final Symbol RPAREN = _symbols[offset + 3];
					 formatting.addParenthesis(LPAREN, RPAREN);
						   return a;
			}
			case 207: // primary = function_call.function_call
			{
					final Symbol _symbol_function_call = _symbols[offset + 1];
					final FunctionCall function_call = (FunctionCall) _symbol_function_call.value;
					 return function_call;
			}
			case 208: // primary = LBRACK.LBRACK matrix.matrix RBRACK.RBRACK
			{
					final Symbol LBRACK = _symbols[offset + 1];
					final Symbol _symbol_matrix = _symbols[offset + 2];
					final Matrix matrix = (Matrix) _symbol_matrix.value;
					final Symbol RBRACK = _symbols[offset + 3];
					 return matrix;
			}
			case 209: // primary = LBRACE.LBRACE function_arguments.function_arguments RBRACE.RBRACE
			{
					final Symbol LBRACE = _symbols[offset + 1];
					final Symbol _symbol_function_arguments = _symbols[offset + 2];
					final FunctionArguments function_arguments = (FunctionArguments) _symbol_function_arguments.value;
					final Symbol RBRACE = _symbols[offset + 3];
					 return new ArrayConstructor(function_arguments);
			}
			case 210: // primary = TIME.TIME
			{
					final Symbol TIME = _symbols[offset + 1];
					 return new TimeExp();
			}
			case 211: // primary = END.END
			{
					final Symbol END = _symbols[offset + 1];
					 return new EndExp();
			}
			case 212: // function_call = parse_access.parse_access LPAREN.LPAREN function_arguments_opt.function_arguments RPAREN.RPAREN
			{
					final Symbol _symbol_parse_access = _symbols[offset + 1];
					final Access parse_access = (Access) _symbol_parse_access.value;
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_function_arguments = _symbols[offset + 3];
					final Opt function_arguments = (Opt) _symbol_function_arguments.value;
					final Symbol RPAREN = _symbols[offset + 4];
					 return new FunctionCall(parse_access, function_arguments);
			}
			case 213: // partial_function_call = FUNCTION.FUNCTION parse_access.parse_access LPAREN.LPAREN function_arguments_named_opt.function_arguments_named RPAREN.RPAREN
			{
					final Symbol FUNCTION = _symbols[offset + 1];
					final Symbol _symbol_parse_access = _symbols[offset + 2];
					final Access parse_access = (Access) _symbol_parse_access.value;
					final Symbol LPAREN = _symbols[offset + 3];
					final Symbol _symbol_function_arguments_named = _symbols[offset + 4];
					final Opt function_arguments_named = (Opt) _symbol_function_arguments_named.value;
					final Symbol RPAREN = _symbols[offset + 5];
					 return new PartialFunctionCall(parse_access, function_arguments_named);
			}
			case 214: // partial_function_call = FUNCTION.FUNCTION parse_access.parse_access
			{
					final Symbol FUNCTION = _symbols[offset + 1];
					final Symbol _symbol_parse_access = _symbols[offset + 2];
					final Access parse_access = (Access) _symbol_parse_access.value;
					 return new PartialFunctionCall(parse_access, new Opt());
			}
			case 215: // function_arguments = exp.exp FOR.FOR for_indices.for_indices
			{
					final Symbol _symbol_exp = _symbols[offset + 1];
					final Exp exp = (Exp) _symbol_exp.value;
					final Symbol FOR = _symbols[offset + 2];
					final Symbol _symbol_for_indices = _symbols[offset + 3];
					final List for_indices = (List) _symbol_for_indices.value;
					 List arg_list_f = new List().add(new IterExp(exp, for_indices));
                                         return new FunctionArguments(arg_list_f, new List());
			}
			case 216: // function_arguments = arg_list_p.arg_list_p
			{
					final Symbol _symbol_arg_list_p = _symbols[offset + 1];
					final List arg_list_p = (List) _symbol_arg_list_p.value;
					 return new FunctionArguments(arg_list_p, new List());
			}
			case 217: // function_arguments = arg_list_p.arg_list_p COMMA.COMMA named_arguments.named_arguments
			{
					final Symbol _symbol_arg_list_p = _symbols[offset + 1];
					final List arg_list_p = (List) _symbol_arg_list_p.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_named_arguments = _symbols[offset + 3];
					final List named_arguments = (List) _symbol_named_arguments.value;
					 return new FunctionArguments(arg_list_p, named_arguments);
			}
			case 219: // function_arguments_named = named_arguments.named_arguments
			{
					final Symbol _symbol_named_arguments = _symbols[offset + 1];
					final List named_arguments = (List) _symbol_named_arguments.value;
					 return new FunctionArguments(new List(), named_arguments);
			}
			case 220: // named_arguments = named_argument.named_argument
			{
					final Symbol _symbol_named_argument = _symbols[offset + 1];
					final NamedArgument named_argument = (NamedArgument) _symbol_named_argument.value;
					 return new List().add(named_argument);
			}
			case 221: // named_arguments = named_arguments.named_arguments COMMA.COMMA named_argument.named_argument
			{
					final Symbol _symbol_named_arguments = _symbols[offset + 1];
					final List named_arguments = (List) _symbol_named_arguments.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_named_argument = _symbols[offset + 3];
					final NamedArgument named_argument = (NamedArgument) _symbol_named_argument.value;
					 return named_arguments.add(named_argument);
			}
			case 222: // function_argument_exp = exp.exp
			{
					final Symbol _symbol_exp = _symbols[offset + 1];
					final Exp exp = (Exp) _symbol_exp.value;
					 return exp;
			}
			case 223: // function_argument_exp = partial_function_call.partial_function_call
			{
					final Symbol _symbol_partial_function_call = _symbols[offset + 1];
					final PartialFunctionCall partial_function_call = (PartialFunctionCall) _symbol_partial_function_call.value;
					 return partial_function_call;
			}
			case 224: // named_argument = named_argument_id.named_argument_id EQUALS.EQUALS function_argument_exp.function_argument_exp
			{
					final Symbol _symbol_named_argument_id = _symbols[offset + 1];
					final Access named_argument_id = (Access) _symbol_named_argument_id.value;
					final Symbol EQUALS = _symbols[offset + 2];
					final Symbol _symbol_function_argument_exp = _symbols[offset + 3];
					final Exp function_argument_exp = (Exp) _symbol_function_argument_exp.value;
					 return new NamedArgument(named_argument_id,function_argument_exp);
			}
			case 225: // named_argument_id = ID.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new ParseAccess(((String)id.value), new Opt());
			}
			case 226: // matrix = matrix_row.matrix_row
			{
					final Symbol _symbol_matrix_row = _symbols[offset + 1];
					final MatrixRow matrix_row = (MatrixRow) _symbol_matrix_row.value;
					 return new Matrix(new List().add(matrix_row));
			}
			case 227: // matrix = matrix.matrix SEMICOLON.SEMICOLON matrix_row.matrix_row
			{
					final Symbol _symbol_matrix = _symbols[offset + 1];
					final Matrix matrix = (Matrix) _symbol_matrix.value;
					final Symbol SEMICOLON = _symbols[offset + 2];
					final Symbol _symbol_matrix_row = _symbols[offset + 3];
					final MatrixRow matrix_row = (MatrixRow) _symbol_matrix_row.value;
					 matrix.addRow(matrix_row); 
                                    return matrix;
			}
			case 228: // matrix_row = exp.exp
			{
					final Symbol _symbol_exp = _symbols[offset + 1];
					final Exp exp = (Exp) _symbol_exp.value;
					 return new MatrixRow(new List().add(exp));
			}
			case 229: // matrix_row = matrix_row.matrix_row COMMA.COMMA exp.exp
			{
					final Symbol _symbol_matrix_row = _symbols[offset + 1];
					final MatrixRow matrix_row = (MatrixRow) _symbol_matrix_row.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_exp = _symbols[offset + 3];
					final Exp exp = (Exp) _symbol_exp.value;
					 matrix_row.addExp(exp); 
                             return matrix_row;
			}
			case 230: // arg_list = 
			{
					 return new List();
			}
			case 231: // arg_list = exp.exp
			{
					final Symbol _symbol_exp = _symbols[offset + 1];
					final Exp exp = (Exp) _symbol_exp.value;
					 return new List().add(exp);
			}
			case 232: // arg_list = arg_list.arg_list COMMA.COMMA exp.exp
			{
					final Symbol _symbol_arg_list = _symbols[offset + 1];
					final List arg_list = (List) _symbol_arg_list.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_exp = _symbols[offset + 3];
					final Exp exp = (Exp) _symbol_exp.value;
					 arg_list.add(exp); 
                           return arg_list;
			}
			case 233: // arg_list_p = function_argument_exp.function_argument_exp
			{
					final Symbol _symbol_function_argument_exp = _symbols[offset + 1];
					final Exp function_argument_exp = (Exp) _symbol_function_argument_exp.value;
					 return new List().add(function_argument_exp);
			}
			case 234: // arg_list_p = arg_list_p.arg_list_p COMMA.COMMA function_argument_exp.function_argument_exp
			{
					final Symbol _symbol_arg_list_p = _symbols[offset + 1];
					final List arg_list_p = (List) _symbol_arg_list_p.value;
					final Symbol COMMA = _symbols[offset + 2];
					final Symbol _symbol_function_argument_exp = _symbols[offset + 3];
					final Exp function_argument_exp = (Exp) _symbol_function_argument_exp.value;
					 return arg_list_p.add(function_argument_exp);
			}
			case 235: // comment = string_comment_opt.string_comment annotation_opt.annotation
			{
					final Symbol _symbol_string_comment = _symbols[offset + 1];
					final Opt string_comment = (Opt) _symbol_string_comment.value;
					final Symbol _symbol_annotation = _symbols[offset + 2];
					final Opt annotation = (Opt) _symbol_annotation.value;
					 return new Comment(string_comment,annotation);
			}
			case 236: // string_comment = STRING.s
			{
					final Symbol s = _symbols[offset + 1];
					 return new StringComment(((String)s.value));
			}
			case 237: // string_comment = string_comment.string_comment PLUS.PLUS STRING.s
			{
					final Symbol _symbol_string_comment = _symbols[offset + 1];
					final StringComment string_comment = (StringComment) _symbol_string_comment.value;
					final Symbol PLUS = _symbols[offset + 2];
					final Symbol s = _symbols[offset + 3];
					 string_comment.setComment(string_comment.getComment().concat(((String)s.value)));
                                    return string_comment;
			}
			case 238: // id_decl = ID.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new IdDecl(((String)id.value));
			}
			case 239: // access_expression = parse_access.parse_access
			{
					final Symbol _symbol_parse_access = _symbols[offset + 1];
					final Access parse_access = (Access) _symbol_parse_access.value;
					 return new AccessExp(parse_access);
			}
			case 240: // der_expression = DER.DER LPAREN.LPAREN exp.exp RPAREN.RPAREN
			{
					final Symbol DER = _symbols[offset + 1];
					final Symbol LPAREN = _symbols[offset + 2];
					final Symbol _symbol_exp = _symbols[offset + 3];
					final Exp exp = (Exp) _symbol_exp.value;
					final Symbol RPAREN = _symbols[offset + 4];
					 return new DerExp(exp);
			}
			case 241: // parse_access = parse_access_loc.parse_access_loc
			{
					final Symbol _symbol_parse_access_loc = _symbols[offset + 1];
					final Access parse_access_loc = (Access) _symbol_parse_access_loc.value;
					 return parse_access_loc;
			}
			case 242: // parse_access = DOT.DOT first_class_access.first_class_access
			{
					final Symbol DOT = _symbols[offset + 1];
					final Symbol _symbol_first_class_access = _symbols[offset + 2];
					final Access first_class_access = (Access) _symbol_first_class_access.value;
					 return new GlobalAccess(first_class_access);
			}
			case 243: // parse_access_loc = parse_access_single.parse_access_single
			{
					final Symbol _symbol_parse_access_single = _symbols[offset + 1];
					final ParseAccess parse_access_single = (ParseAccess) _symbol_parse_access_single.value;
					 return parse_access_single;
			}
			case 244: // parse_access_loc = parse_access_single.parse_access_single DOT.DOT parse_access_loc.parse_access_loc
			{
					final Symbol _symbol_parse_access_single = _symbols[offset + 1];
					final ParseAccess parse_access_single = (ParseAccess) _symbol_parse_access_single.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_parse_access_loc = _symbols[offset + 3];
					final Access parse_access_loc = (Access) _symbol_parse_access_loc.value;
					 return new PN_Dot(parse_access_single, parse_access_loc);
			}
			case 245: // first_class_access = class_access_single.class_access_single
			{
					final Symbol _symbol_class_access_single = _symbols[offset + 1];
					final ClassAccess class_access_single = (ClassAccess) _symbol_class_access_single.value;
					 return class_access_single;
			}
			case 246: // first_class_access = class_access_single.class_access_single DOT.DOT parse_access_loc.parse_access_loc
			{
					final Symbol _symbol_class_access_single = _symbols[offset + 1];
					final ClassAccess class_access_single = (ClassAccess) _symbol_class_access_single.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_parse_access_loc = _symbols[offset + 3];
					final Access parse_access_loc = (Access) _symbol_parse_access_loc.value;
					 return new PN_Dot(class_access_single, parse_access_loc);
			}
			case 247: // parse_access_single = ID.id array_subscripts_opt.array_subscripts
			{
					final Symbol id = _symbols[offset + 1];
					final Symbol _symbol_array_subscripts = _symbols[offset + 2];
					final Opt array_subscripts = (Opt) _symbol_array_subscripts.value;
					 return new ParseAccess(((String)id.value), array_subscripts);
			}
			case 248: // parse_access_single_simple = ID.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new ParseAccess(((String)id.value), new Opt());
			}
			case 249: // qualified_import_access = qualified_import_access_loc.qualified_import_access_loc
			{
					final Symbol _symbol_qualified_import_access_loc = _symbols[offset + 1];
					final Access qualified_import_access_loc = (Access) _symbol_qualified_import_access_loc.value;
					 return qualified_import_access_loc;
			}
			case 250: // qualified_import_access = DOT.DOT qualified_import_access_loc.qualified_import_access_loc
			{
					final Symbol DOT = _symbols[offset + 1];
					final Symbol _symbol_qualified_import_access_loc = _symbols[offset + 2];
					final Access qualified_import_access_loc = (Access) _symbol_qualified_import_access_loc.value;
					 return new GlobalAccess(qualified_import_access_loc);
			}
			case 251: // qualified_import_access_loc = qualified_import_access_rec.qualified_import_access_rec
			{
					final Symbol _symbol_qualified_import_access_rec = _symbols[offset + 1];
					final Access qualified_import_access_rec = (Access) _symbol_qualified_import_access_rec.value;
					 return qualified_import_access_rec;
			}
			case 252: // qualified_import_access_loc = class_access_single.class_access_single
			{
					final Symbol _symbol_class_access_single = _symbols[offset + 1];
					final ClassAccess class_access_single = (ClassAccess) _symbol_class_access_single.value;
					 return class_access_single;
			}
			case 253: // qualified_import_access_rec = class_access_single.class_access_single DOT.DOT parse_access_single_simple.parse_access_single_simple
			{
					final Symbol _symbol_class_access_single = _symbols[offset + 1];
					final ClassAccess class_access_single = (ClassAccess) _symbol_class_access_single.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_parse_access_single_simple = _symbols[offset + 3];
					final ParseAccess parse_access_single_simple = (ParseAccess) _symbol_parse_access_single_simple.value;
					 return new PN_Dot(class_access_single, parse_access_single_simple);
			}
			case 254: // qualified_import_access_rec = class_access_single.class_access_single DOT.DOT qualified_import_access_rec.qualified_import_access_rec
			{
					final Symbol _symbol_class_access_single = _symbols[offset + 1];
					final ClassAccess class_access_single = (ClassAccess) _symbol_class_access_single.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_qualified_import_access_rec = _symbols[offset + 3];
					final Access qualified_import_access_rec = (Access) _symbol_qualified_import_access_rec.value;
					 return new PN_Dot(class_access_single, qualified_import_access_rec);
			}
			case 255: // unqualified_import_access = class_access.class_access DOTMULT.DOTMULT
			{
					final Symbol _symbol_class_access = _symbols[offset + 1];
					final Access class_access = (Access) _symbol_class_access.value;
					final Symbol DOTMULT = _symbols[offset + 2];
					 return class_access;
			}
			case 256: // class_access = class_access_loc.class_access_loc
			{
					final Symbol _symbol_class_access_loc = _symbols[offset + 1];
					final Access class_access_loc = (Access) _symbol_class_access_loc.value;
					 return class_access_loc;
			}
			case 257: // class_access = DOT.DOT class_access_loc.class_access_loc
			{
					final Symbol DOT = _symbols[offset + 1];
					final Symbol _symbol_class_access_loc = _symbols[offset + 2];
					final Access class_access_loc = (Access) _symbol_class_access_loc.value;
					 return new GlobalAccess(class_access_loc);
			}
			case 258: // class_access_loc = class_access_single.class_access_single
			{
					final Symbol _symbol_class_access_single = _symbols[offset + 1];
					final ClassAccess class_access_single = (ClassAccess) _symbol_class_access_single.value;
					 return class_access_single;
			}
			case 259: // class_access_loc = class_access_single.class_access_single DOT.DOT class_access_loc.class_access_loc
			{
					final Symbol _symbol_class_access_single = _symbols[offset + 1];
					final ClassAccess class_access_single = (ClassAccess) _symbol_class_access_single.value;
					final Symbol DOT = _symbols[offset + 2];
					final Symbol _symbol_class_access_loc = _symbols[offset + 3];
					final Access class_access_loc = (Access) _symbol_class_access_loc.value;
					 return new PN_Dot(class_access_single, class_access_loc);
			}
			case 260: // class_access_single = ID.id
			{
					final Symbol id = _symbols[offset + 1];
					 return new ClassAccess(((String)id.value));
			}
			case 261: // end_decl = END_ID.END_ID
			{
					final Symbol END_ID = _symbols[offset + 1];
					 String value = (String) END_ID.value;
             String id = value.substring(3, value.length()).trim();
             return new EndDecl(id);
			}
			case 262: // string_comment_opt = 
			{
					 return new Opt();
			}
			case 263: // string_comment_opt = string_comment.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final StringComment n = (StringComment) _symbol_n.value;
					 return new Opt(n);
			}
			case 264: // function_arguments_opt = 
			{
					 return new Opt();
			}
			case 265: // function_arguments_opt = function_arguments.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final FunctionArguments n = (FunctionArguments) _symbol_n.value;
					 return new Opt(n);
			}
			case 266: // value_modification_opt = 
			{
					 return new Opt();
			}
			case 267: // value_modification_opt = value_modification.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ValueModification n = (ValueModification) _symbol_n.value;
					 return new Opt(n);
			}
			case 268: // constraining_clause_opt = 
			{
					 return new Opt();
			}
			case 269: // constraining_clause_opt = constraining_clause.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ConstrainingClause n = (ConstrainingClause) _symbol_n.value;
					 return new Opt(n);
			}
			case 270: // outer_opt = 
			{
					 return new Opt();
			}
			case 271: // outer_opt = outer.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Outer n = (Outer) _symbol_n.value;
					 return new Opt(n);
			}
			case 272: // each_opt = 
			{
					 return new Opt();
			}
			case 273: // each_opt = each.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Each n = (Each) _symbol_n.value;
					 return new Opt(n);
			}
			case 274: // parse_access_opt = 
			{
					 return new Opt();
			}
			case 275: // parse_access_opt = parse_access.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Access n = (Access) _symbol_n.value;
					 return new Opt(n);
			}
			case 276: // type_prefix_variability_opt = 
			{
					 return new Opt();
			}
			case 277: // type_prefix_variability_opt = type_prefix_variability.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final TypePrefix n = (TypePrefix) _symbol_n.value;
					 return new Opt(n);
			}
			case 278: // for_in_exp_opt = 
			{
					 return new Opt();
			}
			case 279: // for_in_exp_opt = for_in_exp.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Exp n = (Exp) _symbol_n.value;
					 return new Opt(n);
			}
			case 280: // partial_opt = 
			{
					 return new Opt();
			}
			case 281: // partial_opt = partial.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Partial n = (Partial) _symbol_n.value;
					 return new Opt(n);
			}
			case 282: // type_prefix_input_output_opt = 
			{
					 return new Opt();
			}
			case 283: // type_prefix_input_output_opt = type_prefix_input_output.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final TypePrefix n = (TypePrefix) _symbol_n.value;
					 return new Opt(n);
			}
			case 284: // else_if_equation_opt = 
			{
					 return new Opt();
			}
			case 285: // else_if_equation_opt = else_if_equation.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final IfWhenElseEquation n = (IfWhenElseEquation) _symbol_n.value;
					 return new Opt(n);
			}
			case 286: // annotation_sc_opt = 
			{
					 return new Opt();
			}
			case 287: // annotation_sc_opt = annotation_sc.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Annotation n = (Annotation) _symbol_n.value;
					 return new Opt(n);
			}
			case 288: // class_modification_opt = 
			{
					 return new Opt();
			}
			case 289: // class_modification_opt = class_modification.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ClassModification n = (ClassModification) _symbol_n.value;
					 return new Opt(n);
			}
			case 290: // annotation_opt = 
			{
					 return new Opt();
			}
			case 291: // annotation_opt = annotation.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Annotation n = (Annotation) _symbol_n.value;
					 return new Opt(n);
			}
			case 292: // within_opt = 
			{
					 return new Opt();
			}
			case 293: // within_opt = within.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Within n = (Within) _symbol_n.value;
					 return new Opt(n);
			}
			case 294: // function_arguments_named_opt = 
			{
					 return new Opt();
			}
			case 295: // function_arguments_named_opt = function_arguments_named.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final FunctionArguments n = (FunctionArguments) _symbol_n.value;
					 return new Opt(n);
			}
			case 296: // abstract_equation_opt_list = 
			{
					 return new List();
			}
			case 297: // abstract_equation_opt_list = abstract_equation_list.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final List n = (List) _symbol_n.value;
					 return n;
			}
			case 298: // abstract_equation_list = abstract_equation.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final AbstractEquation n = (AbstractEquation) _symbol_n.value;
					 return new List().add(n);
			}
			case 299: // abstract_equation_list = abstract_equation_list.l abstract_equation.n
			{
					final Symbol _symbol_l = _symbols[offset + 1];
					final List l = (List) _symbol_l.value;
					final Symbol _symbol_n = _symbols[offset + 2];
					final AbstractEquation n = (AbstractEquation) _symbol_n.value;
					 return l.add(n);
			}
			case 300: // external_function_call_opt = 
			{
					 return new Opt();
			}
			case 301: // external_function_call_opt = external_function_call.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ExternalFunctionCall n = (ExternalFunctionCall) _symbol_n.value;
					 return new Opt(n);
			}
			case 302: // external_language_opt = 
			{
					 return new Opt();
			}
			case 303: // external_language_opt = external_language.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ExternalLanguage n = (ExternalLanguage) _symbol_n.value;
					 return new Opt(n);
			}
			case 304: // final__opt = 
			{
					 return new Opt();
			}
			case 305: // final__opt = final_.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Final n = (Final) _symbol_n.value;
					 return new Opt(n);
			}
			case 306: // else_when_equation_opt = 
			{
					 return new Opt();
			}
			case 307: // else_when_equation_opt = else_when_equation.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final WhenEquation n = (WhenEquation) _symbol_n.value;
					 return new Opt(n);
			}
			case 308: // external_clause_opt = 
			{
					 return new Opt();
			}
			case 309: // external_clause_opt = external_clause.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ExternalClause n = (ExternalClause) _symbol_n.value;
					 return new Opt(n);
			}
			case 310: // inner_opt = 
			{
					 return new Opt();
			}
			case 311: // inner_opt = inner.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Inner n = (Inner) _symbol_n.value;
					 return new Opt(n);
			}
			case 312: // modification_opt = 
			{
					 return new Opt();
			}
			case 313: // modification_opt = modification.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Modification n = (Modification) _symbol_n.value;
					 return new Opt(n);
			}
			case 314: // conditional_attribute_opt = 
			{
					 return new Opt();
			}
			case 315: // conditional_attribute_opt = conditional_attribute.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ConditionalAttribute n = (ConditionalAttribute) _symbol_n.value;
					 return new Opt(n);
			}
			case 316: // type_prefix_flow_opt = 
			{
					 return new Opt();
			}
			case 317: // type_prefix_flow_opt = type_prefix_flow.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final TypePrefix n = (TypePrefix) _symbol_n.value;
					 return new Opt(n);
			}
			case 318: // encapsulated_opt = 
			{
					 return new Opt();
			}
			case 319: // encapsulated_opt = encapsulated.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Encapsulated n = (Encapsulated) _symbol_n.value;
					 return new Opt(n);
			}
			case 320: // redeclare_opt = 
			{
					 return new Opt();
			}
			case 321: // redeclare_opt = redeclare.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final Redeclare n = (Redeclare) _symbol_n.value;
					 return new Opt(n);
			}
			case 322: // array_subscripts_opt = 
			{
					 return new Opt();
			}
			case 323: // array_subscripts_opt = array_subscripts.n
			{
					final Symbol _symbol_n = _symbols[offset + 1];
					final ArraySubscripts n = (ArraySubscripts) _symbol_n.value;
					 return new Opt(n);
			}
			case 0: // $goal = source_root
			case 218: // function_arguments = function_arguments_named.function_arguments_named
			{
				return _symbols[offset + 1];
			}
			case 1: // $goal = $anonymous_short_class anonymous_short_class
			case 2: // $goal = $exp exp
			{
				return _symbols[offset + 2];
			}
			default:
				throw new IllegalArgumentException("unknown production #" + rule_num);
		}
	}
}
